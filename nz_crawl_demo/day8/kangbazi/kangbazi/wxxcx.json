{"title": "微信小程序开发中 var that =this的用法 ", "content": "在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量", "pub_time": "2020-2-6 00:52", "author": "Rolan"}
{"title": "源码级别高度定制小程序vant弹窗组件 ", "content": "作为从事前端开发的你肯定见过不少的弹框组件，你可曾有想过要自己实现一个弹框组件库，又或者想完全定制化的使用各种标准UI框架中的弹框组件呢？今天这篇文章将会带着你解析这一系列疑问，以vant-weapp组件库为例，从开发标准的弹窗组件使用到高度定制复合自我审美的弹窗，再到完全研究清楚vant-weapp框架弹窗组件部分源码。一、vant-weapp弹窗组件介绍vant-weapp组件库是有赞团队开发的 一款灵活简洁且美观的小程序UI组件库 ，此文将以这个组件库的用法为标准，下文提及的弹框组件均指的是此组件库中的弹框。弹框分类vant-weapp中弹框主要分为**两大类：弹出层Popup和对话框Dialog，**弹出层一般是带有背景遮罩层和内容展示区域用于在不跳转页面情况下进行详情的展示作用，对话框多数用于带有详情展示的同时还带有希望用户确认等操作。如下图所示，图左为典型的Dialog，图右为典型的Popup。注册小程序组件在使用弹框组件之前记得在小程序的app.json文件中先注册组件，详细介绍见 快速上手 ，例如注册van-popup组件代码如下：// app.json\r\n\"usingComponents\": {\r\n  \"van-popup\": \"path/to/@vant/weapp/dist/popup/index\"\r\n}\r\n复制代码在项目中实际使用如下：在本文后续分析van-dialog源码中会发现在dialog的index.json中也定义过van-popup组件，但是我们要直接实行van-popup组件必须在小程序的配置文件app.json中按照上图方式进行定义，微信小程序官网说明过 自定义组件内部的引入组件只在该组件内生效注册完组件之后，就可以直接在小程序页面中使用这里注册的自定义组件，组件名称为这里 key ，例如：。二、Popup基本用法常见用法最常见的用法就是直接使用van-popup组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是popup组件的内容，如下所示：// wxml\r\n<button bindtap=\"showPopup\">展示弹出层</button>\r\n<van-popup\r\n\tshow=\"{{ show }}\"\r\n\tposition=\"top\"\r\n\tbind:close=\"onClose\"\r\n  closeable\r\n>内容</van-popup>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: false\r\n  },\r\n  showPopup() {\r\n    this.setData({ show: true });\r\n  },\r\n  onClose() {\r\n    this.setData({ show: false });\r\n  }\r\n});\r\n复制代码重点属性分析van-popup组件可以通过position属性的五个值： center、top、right、bottom、left 来快捷的控制是从哪个位置弹出，例如：上例中的弹框从上往下弹出可以通过round属性来控制弹窗内容是否显示圆角，closeable可以决定是否显示关闭弹框的图标按钮，例如：上例中的弹窗将不显示圆角，同时显示关闭按钮各种基本的弹窗形式如下：三、Dialog对话框基本用法对话框则是在popup弹出层的基础上添加了额外的内置的标题，快速确定按钮等组件，用于消息提示、消息确认等场景，下面看看其常见用法。常规用法——带标题最常规的用法就是直接使用van-dialog组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是dialog组件的内容，如下所示：// wxml\r\n<van-dialog\r\n  title=\"标题\"\r\n\tmessage=\"代码是写出来给人看的，附带能在机器上运行\"\r\n  show=\"{{ show }}\"\r\n  confirm-button-open-type=\"getUserInfo\"\r\n  bind:close=\"onClose\"\r\n  bind:getuserinfo=\"getUserInfo\"\r\n>\r\n  <image src=\"https://img.yzcdn.cn/1.jpg\" />\r\n</van-dialog>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  getUserInfo(event) {\r\n    console.log(event.detail);\r\n  },\r\n  onClose() {\r\n    this.setData({ close: false });\r\n  }\r\n});\r\n复制代码常规用法——无标题直接使用van-dialog组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是dialog组件的内容，不使用use-title-slot且不传递title属性，如下所示：// wxml\r\n<van-dialog\r\n  show=\"{{ show }}\"\r\n  confirm-button-open-type=\"getUserInfo\"\r\n  bind:close=\"onClose\"\r\n  bind:getuserinfo=\"getUserInfo\"\r\n>\r\n  <view class=\"message\">代码是写出来给人看的，附带能在机器上运行</view>\r\n</van-dialog>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  getUserInfo(event) {\r\n    console.log(event.detail);\r\n  },\r\n  onClose() {\r\n    this.setData({ close: false });\r\n  }\r\n});\r\n复制代码上述两种用法中的use-slot属性表示使用默认的slot（即van-dialog嵌套的wxml内容，比如此处的 ...）来作为内容输出，bind:getuserinfo等是使用的微信开发能力（即在点击确定按钮时候对调用微信平台API获取到对应的信息，此处是获取用户个人身份信息）函数式调用——confirm最常规的另一种用法就是直接使用 Dialog、Dialog.alert、Dialog.confirm 的方法快速打开弹窗组件，关闭弹框组件则通过 Dialog.close ，取消弹框的加载状态则使用 Dialog.stopLoading，组件内部嵌套的其他组件或标签是dialog组件的内容，如下所示：// wxml\r\n<van-dialog id=\"van-dialog\">\r\nimport Dialog from 'path/to/@vant/weapp/dist/dialog/dialog';\r\n\r\n// js\r\nDialog.alert({\r\n  title: \"标题\"\r\n  message: '代码是写出来给人看的，附带能在机器上运行'\r\n}).then(() => {\r\n  // on close\r\n});\r\n\r\n复制代码这里使用函数调用一定要注意在使用van-dialog的页面的wxml中一定需要写这个来使用组件，下文在分析dialog的源码中会讲到（卖个关子），或者你可以先猜一猜:blush::blush:上面三种van-dialog的常规使用方法的效果如下：四、Dialog进阶用法下面将会提供几个作者在实战中写出的Dialog对话框组件的实战用法使用use-title-slot定制标题<van-dialog\r\n  id=\"van-dialog\"\r\n  show=\"{{ dialogShow }}\"\r\n  message=\"资质原件拍照或扫描可以不加盖公章，复印件需盖章\\n\\n如是三证合一，则无需提供税务登记证、组织机构代码证\"\r\n  message-align=\"left\"\r\n  confirm-button-text=\"知道了\"\r\n  confirm-button-color=\"#EE712F\"\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" class=\" merchant-dialog__title\">\r\n    <view class=\"merchant-dialog__title-text\">开户前，请准备以下资料</view>\r\n    <van-icon name=\"cross\" size=\"40rpx\" class=\"merchant-dialog__title-icon\" bindtap=\"closeDialog\" />\r\n  </view>\r\n</van-dialog>\r\n// 样式部分的代码此处省略\r\n复制代码触发弹框显示handleButtonClick1: function () {\r\n  this.setData({\r\n  \tdialogShow: true\r\n  })\r\n},\r\n复制代码此例子如要使用了如下特性：use-title-slot\r\nconfirm-button-text、confirm-button-color\r\nvan-icon\r\n对应的效果如下：使用use-slot定制提示内容<van-dialog\r\n  id=\"van-dialog-2\"\r\n  use-slot\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" style=\"padding-bottom: 10px;\">\r\n    <van-icon name=\"close\" color=\"#fff\" size=\"30\" bindtap=\"closeDialog2\" />\r\n  </view>\r\n  <image class=\"image\" src=\"https://tva1.sinaimg.cn/large/0082zybply1gbylbcwm44j30rs13bdsg.jpg\" mode=\"aspectFit\"></image>\r\n</van-dialog>\r\n复制代码通过触发弹框显示handleButtonClick2: function () {\r\n  Dialog({\r\n    selector: '#van-dialog-2',\r\n    showConfirmButton: false,\r\n    closeOnClickOverlay: false,\r\n    className: 'dialog2',\r\n    width: '260px'\r\n  })\r\n},\r\n复制代码此例子如要使用了如下特性：使用 use-slot 表示使用默认的slot来内容来渲染到弹框主体内容位置渲染的内容为一张图片，以此来 实现幕帘curtain效果使用 className 这个 externalClasses 来用页面样式控制组件内部样式对应效果如下：使用css变量定义主题<van-dialog\r\n  id=\"van-dialog-3\"\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" style=\"color: #000;\">提示</view>\r\n  <view>\r\n    <view>为了给你推荐更合适的漫展～</view>\r\n    <view>请开启定位权限～</view>\r\n  </view>\r\n</van-dialog>\r\n复制代码通过触发弹框显示handleButtonClick3: function () {\r\n  Dialog({\r\n    selector: '#van-dialog-3',\r\n    showCancelButton: true,\r\n    cancelButtonTrext: '取消',\r\n    confirmButtonText: '去设置',\r\n    cancelButtonColor: '#C46B85',\r\n    confirmButtonColor: '#C46B85',\r\n    message: '为了给你推荐更合适的漫展～\\n请开启定位权限～',\r\n    confirmButtonOpenType: 'openSetting',\r\n    width: '260px',\r\n    className: 'dialog3'\r\n  })\r\n},\r\n复制代码外部样式类.dialog-index--dialog3 {\r\n  --dialog-background-color: rgba(255,255,255,0.8);\r\n  --popup-background-color: rgba(255,255,255,0.8);\r\n  --button-default-background-color: transparent;\r\n  color: #666;\r\n}\r\n复制代码此例子如要使用了如下特性：cancelButtonColor、confirmButtonColor\r\n--dialog-background-color\r\n对应效果如下：五、开发实际场景中的弹窗组件如果你仔细看过上面中的三种自定义方式的实现代码应该也可以根据UI需求实现自己的弹窗交互效果；这里我已经基于前面提到的三种用法来开发了几个实际场景中的弹框组件：实现幕帘curtain效果实现操作权限提示提示应用升级应用使用提示这部分的可以直接去看源码 github.com/JohnieXu/va…也可以扫码这个小程序二维码查看效果六、源码分析的前置条件在看完上面几种炫酷的弹框效果后，我们还是按照惯例研究下如此强大的弹框组件的源码。在研究弹框部分源码之前有必有分析一下一套完整UI框架所需要注意的框架级别的整体架构如何使用less工程化处理样式处理样式是所有UI框架比不可忽略的核心逻辑之一，在vant-weapp中对样式的处理主要分为以下三部分；源码对应结构如下图所示，使用less的mixins复用实现主题变量控制、公共样式抽离等。主题变量在var.less文件定义了框架所用到的全部的样式控制相关的变量，其中与弹框相关的部分源码如下：// Dialog\r\n@dialog-width: 320px;\r\n@dialog-small-screen-width: 90%;\r\n@dialog-font-size: @font-size-lg;\r\n@dialog-border-radius: 16px;\r\n@dialog-background-color: @white;\r\n@dialog-header-font-weight: @font-weight-bold;\r\n@dialog-header-line-height: 24px;\r\n@dialog-header-padding-top: @padding-lg;\r\n@dialog-header-isolated-padding: @padding-lg 0;\r\n@dialog-message-padding: @padding-lg;\r\n@dialog-message-font-size: @font-size-md;\r\n@dialog-message-line-height: 20px;\r\n@dialog-message-max-height: 60vh;\r\n@dialog-has-title-message-text-color: @gray-7;\r\n@dialog-has-title-message-padding-top: @padding-sm;\r\n复制代码源码： var.less此文件中的最终会转换成 css变量 ，并非像antd、iview等网页端框架中的样式处理那样编译成变量指向的值。根据css变量作用域的特性，可以在自定义组件的外部样式类中局部覆盖样式变量来改变组件内部的样式。通用样式像清除浮动、文字省略、1像素边框等通用的样式类的处理在mixin文件夹下清除浮动.clearfix() {\r\n  &::after {\r\n    display: table;\r\n    clear: both;\r\n    content: '';\r\n  }\r\n}\r\n复制代码使用常见的after伪类来实现清除浮动文件省略.multi-ellipsis(@lines) {\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  -webkit-line-clamp: @lines;\r\n  /* autoprefixer: ignore next */\r\n  -webkit-box-orient: vertical;\r\n}\r\n.ellipsis() {\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n复制代码使用less的函数封装了两个处理文字省略方法：单行省略、多行省略BEM命名如何工程化的注册自定义组件微信小程序官方提供了 Component构造方法 注册自定义组件，为了结合typescript给自定义组件提供更灵活强大的组件注册器对Component进行了下面的功能封装处理封装通用组件构造方法function VantComponent<Data, Props, Methods>(\r\n  vantOptions: VantComponentOptions<\r\n    Data,\r\n    Props,\r\n    Methods,\r\n    CombinedComponentInstance<Data, Props, Methods>\r\n  > = {}\r\n): void {\r\n  const options: any = {};\r\n  mapKeys(vantOptions, options, {\r\n    data: 'data',\r\n    props: 'properties',\r\n    mixins: 'behaviors',\r\n    methods: 'methods',\r\n    beforeCreate: 'created',\r\n    created: 'attached',\r\n    mounted: 'ready',\r\n    relations: 'relations',\r\n    destroyed: 'detached',\r\n    classes: 'externalClasses'\r\n  });\r\n  const { relation } = vantOptions;\r\n  if (relation) {\r\n    makeRelation(options, vantOptions, relation);\r\n  }\r\n  // 给所有组件添加默认外部样式类custom-class\r\n  options.externalClasses = options.externalClasses || [];\r\n  options.externalClasses.push('custom-class');\r\n  // 给所有组件添加默认behaviors\r\n  options.behaviors = options.behaviors || [];\r\n  options.behaviors.push(basic);\r\n  // map field to form-field behavior\r\n  if (vantOptions.field) {\r\n    options.behaviors.push('wx://form-field');\r\n  }\r\n  // 默认启用多slot支持、组件中允许全局样式修改\r\n  options.options = {\r\n    multipleSlots: true,\r\n    addGlobalClass: true\r\n  };\r\n  // 最终使用官网构造方法构造组件\r\n  Component(options);\r\n}\r\n复制代码源码： component.tsbehaviors复用共享逻辑behaviors 是微信小程序官方用于组件复用 data、methods 等属性方法的一种方式，和vue中的 mixins 小作用一致，vant-weapp中定义的 mixins 如下图所示:其中basic是所有自定义组件都复用的一个mxin，给所有自定义的组件提供了三个方法： $emit、 set 和 getRect 。$emit 封装了 triggerEvent 方法；set 封装 setData 方法为Promise形式；getRect 采用Promise方法用查找对应节点的boundingClientRect。源码如下：// basic.ts\r\nexport const basic = Behavior({\r\n  methods: {\r\n    $emit(...args) {\r\n      this.triggerEvent(...args);\r\n    },\r\n    set(data: object, callback: Function) {\r\n      this.setData(data, callback);\r\n\r\n      return new Promise(resolve => wx.nextTick(resolve));\r\n    },\r\n    getRect(selector: string, all: boolean) {\r\n      return new Promise(resolve => {\r\n        wx.createSelectorQuery()\r\n          .in(this)[all ? 'selectAll' : 'select'](selector)\r\n          .boundingClientRect(rect => {\r\n            if (all && Array.isArray(rect) && rect.length) {\r\n              resolve(rect);\r\n            }\r\n\r\n            if (!all && rect) {\r\n              resolve(rect);\r\n            }\r\n          })\r\n          .exec();\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n复制代码源码： basic.ts生命周期命名其实生命周期如何命名到不是很重要，vant-weapp对命名进行了转换主要基于以下两个原因：开发效率 ：vant-weapp源自适用于vue的UI组件库—— vant ，命名统一转换便于现有框架的逻辑复用使用成本 ：生命周期命名向主流MVVM框架靠近减轻使用者的学习成本、框架维护成本function mapKeys(source: object, target: object, map: object) {\r\n  Object.keys(map).forEach(key => {\r\n    if (source[key]) {\r\n      target[map[key]] = source[key];\r\n    }\r\n  });\r\n}\r\nmapKeys(vantOptions, options, {\r\n  data: 'data',\r\n  props: 'properties',\r\n  mixins: 'behaviors',\r\n  methods: 'methods',\r\n  beforeCreate: 'created',\r\n  created: 'attached',\r\n  mounted: 'ready',\r\n  relations: 'relations',\r\n  destroyed: 'detached',\r\n  classes: 'externalClasses'\r\n});\r\n复制代码源码： component.ts#L24通过 mapKeys 方法对 VantComponent 中传入的生命周期函数进行了转换，转换名生命周期名称与微信小程序一致自定义组件的样式隔离微信小程序自定义组件默认样式作用域的范围是为当前组件，也就是说组件文件夹下的wxss中的样式只对该文件夹下的wxml生效（除去标签名、ID选择器）这种以组件为单位进行样式隔离的模式类似于React框架中处理的组件样式的库 styled-components组件间样式共享要在组件之前共享样式或者让自定义组件接受外部样式，可行方案有如下几种：| styleIsolation属性配置 |page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。 | styleIsolation 选项从基础库版本 2.6.5 开始支持 | | --- | --- | --- | | addGlobalClass属性配置 | 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面 |小程序基础库版本 2.2.3 以上支持等价于styleIsolation: apply-sharedvant-weapp中使用的是此方案 ： addGlobalClass: 'true' ，默认的 styleIsolation: 'shared' 不生效 | | externalClasses外部样式类 | 组件的使用者可以指定这个样式类对应的外部样式名 ，对应样式名的样式在组件内部生效 |基础库 1.9.90 开始支持vant-weapp中也支持此方式推荐使用此方式来自定义vant-weapp的样式 | | class=\"~blue-text\"引用父组件样式 | 即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式 | 基础库 2.9.2 开始支持 |使用总结使用vant-weapp组件库的使用者最佳的自定义组件样式的方式是： 采用外部样式类+CSS变量，在无相关CSS变量时才用自己的样式+ !important  确保样式优先级 ，在自定义组件中使用vant-weapp的组件时候的注意事项参照 样式覆盖 。自定义组件通信方案自定义组件通信主要包括 组件参数传递 和 事件监听 ，这两个功能都是微信小程序官网提供的；参数传递是由父传到子的单向传递，而事件监听则是相应原生事件或者自定义事件。自定义事件用于对组件的事件进行封装，自定义事件机制如下：这里在van-dialog组件使用位置监听bindclick事件，最终这个事件会在van-dialog组件内部的button的tap时被触发，后面源码分析中的自定义组件的自定义事件全部采用的此种模式。七、Popup弹出层组件源码分析组件部分源码结构popup组件部分源码结构如下：组件的命名规范与微信小程序自定义组件的规范相符合（README.md为组件的使用说明文档，用于生成官网的组件文档说明）。popup组件的配置文件标识当前的index为组件，通过 using-components 引入了 van-icon 和 van-overlay 组件，在对应的wxml中可以直接使用。组件主要逻辑弹出层组件主要分类 遮盖层 和 内容层 ，内容层嵌套在遮盖层内部来确保视觉上覆盖在遮盖层之上。遮盖层及事件遮盖层通过overlay、overlayStyle等组件属性来控制其是否显示以及遮盖层的样式等，遮盖的事件有 onClickOverlay ，通过$emit触发组件的自定义事件close。onClickOverlay() {\r\n  this.$emit('click-overlay');\r\n\r\n  if (this.data.closeOnClickOverlay) {\r\n    this.$emit('close');\r\n  }\r\n}\r\n复制代码关闭按钮及事件通过closable属性决定是否显示默认的关闭按钮，也可以通过关闭图标相关属性配置更改按钮样式，关闭按钮的事件有onClickCloseIcon，通过$emit触发组件的自定义事件close。onClickCloseIcon() {\r\n  this.$emit('close');\r\n},\r\n复制代码内容分发接受一个默认的slot，其位置根据传入的 position 参数不同有 top、right、bottom、left、center 五种，根据这五种位置参数有对应的五种不同的弹出位置和动画过渡动画使用transform来实现动画效果，根据 position 参数的五种情况有五种默认动画// popup/index.less\r\n.van-bottom-enter,\r\n.van-bottom-leave-to {\r\n  transform: translate3d(0, 100%, 0);\r\n}\r\n.van-top-enter,\r\n.van-top-leave-to {\r\n  transform: translate3d(0, -100%, 0);\r\n}\r\n.van-left-enter,\r\n.van-left-leave-to {\r\n  transform: translate3d(-100%, -50%, 0);\r\n}\r\n.van-right-enter,\r\n.van-right-leave-to {\r\n  transform: translate3d(100%, -50%, 0);\r\n}\r\n复制代码同时暴露了外部样式类可以用来自定义动画，这里动画阶段划分和vue相同，分类： enter、enter-active、enter-to、leave、leave-active、leave-to// popup/index.ts\r\nVantComponent({\r\n  classes: [\r\n    'enter-class',\r\n    'enter-active-class',\r\n    'enter-to-class',\r\n    'leave-class',\r\n    'leave-active-class',\r\n    'leave-to-class'\r\n  ],\r\n  ...\r\n}\r\n复制代码八、Dialog对话框组件源码分析组件部分源码结构dialog组件部分源码结构如下：结构同popup组件，不同点在于index.json使用了 van-popup、van-button 组件，以及多了dialog.ts这个暴露API函数调用方法的文件。组件布局结构dialog组件整体基于popup组件，在其默认slot中添加了顶部标题的slot和按钮组元素，大致结构如下源码结构：// dialog/index.wxml\r\n<van-popup\r\n  show=\"{{ show }}\"\r\n  ...\r\n>\r\n  <view\r\n    wx:if=\"{{ title || useTitleSlot  }}\"\r\n    class=\"van-dialog__header {{ message || useSlot ? '' : 'van-dialog--isolated' }}\"\r\n  >\r\n    <slot wx:if=\"{{ useTitleSlot }}\" name=\"title\" />\r\n    <block wx:elif=\"{{ title }}\"> {{ title }}</block>\r\n  </view>\r\n\r\n  <slot wx:if=\"{{ useSlot }}\" />\r\n  <view\r\n    wx:elif=\"{{ message }}\"\r\n    class=\"van-dialog__message {{ title ? 'van-dialog__message--has-title' : '' }} {{ messageAlign ? 'van-dialog__message--' + messageAlign : '' }}\"\r\n  >\r\n    <text class=\"van-dialog__message-text\">{{ message }}</text>\r\n  </view>\r\n\r\n  <view class=\"van-hairline--top van-dialog__footer\">\r\n    <van-button\r\n      wx:if=\"{{ showCancelButton }}\"\r\n      ...\r\n    >\r\n      {{ cancelButtonText }}\r\n    </van-button>\r\n    <van-button\r\n      wx:if=\"{{ showConfirmButton }}\"\r\n      ...\r\n    >\r\n      {{ confirmButtonText }}\r\n    </van-button>\r\n  </view>\r\n</van-popup>\r\n复制代码函数式调用实现在前面中通过Dialog函数调用来打开弹出框组件，实现函数式调用的核心思路主要是： 通过selectComponent(selector)方法查找（类似于查找DOM、Vue中查找组件实例）对页面中定义渲染好的dialog组件，手动更新其组件实例的数据。 ** Dialog方法定义如下：const Dialog: Dialog = options => {\r\n  options = {\r\n    ...Dialog.currentOptions,\r\n    ...options\r\n  };\r\n  return new Promise((resolve, reject) => {\r\n    const context = options.context || getContext();\r\n    const dialog = context.selectComponent(options.selector);\r\n    delete options.context;\r\n    delete options.selector;\r\n    if (dialog) {\r\n      dialog.setData({\r\n        onCancel: reject,\r\n        onConfirm: resolve,\r\n        ...options\r\n      });\r\n      queue.push(dialog);\r\n    } else {\r\n      console.warn('未找到 van-dialog 节点，请确认 selector 及 context 是否正确');\r\n    }\r\n  });\r\n};\r\n复制代码**函数式调用时候根据传入的options配置去更新找到的组件实例上的属性由微信小程序自定义组件限制不能更新slot，slot需要用组件嵌套来传入函数式调用中的options会有默认值强制覆盖掉van-dialog组件属性处传入的非id等其他属性，即函数调用的时通过组件传入的属性无效**Dialog.confirm确认弹窗调用方法Dialog.confirm({\r\n\tselector: '#van-dialog',\r\n\ttitle: '提示',\r\n\tmessage: '这里放置提示内容'\r\n})\r\n复制代码实现方式Dialog.confirm = options =>\r\n  Dialog({\r\n    showCancelButton: true,\r\n    ...options\r\n  });\r\n复制代码调用Dialog时候默认执行定了显示取消按钮，其他无区别Dialog.close关闭弹窗调用方法Dialog.close()\r\n复制代码实现方式Dialog.close = () => {\r\n  queue.forEach(dialog => {\r\n    dialog.close();\r\n  });\r\n  queue = [];\r\n};\r\n复制代码遍历内部缓存的所有调用Dialog方法找到的van-dialog组件实例，执行其close方法Dialog.setDefaultOptions更改对话框默认配置调用方法Dialog.setDefaultOptions(options)\r\n复制代码实现方式Object.assign(Dialog.currentOptions, options);\r\n复制代码通过Object.assign将传入的默认配置合并到内部Dialog.currentOptions配置上Dialog.resetDefaultOptions恢复对话框默认配置调用方法Dialog.resetDefaultOptions()\r\n复制代码实现方式Dialog.resetDefaultOptions = () => {\r\n  Dialog.currentOptions = { ...Dialog.defaultOptions };\r\n};\r\n复制代码恢复Dialog.currentOptions配置为Dialog.defaultOptions总结本文讲解了vant-weapp组件库中的弹框组件的基本用法、进阶用法、定制主题、自定义内容等用法，同时还更进一步的研究了vant-weapp组件中的popup组件、dialog组件的实现。也只有彻底弄懂了UI框架的封装思路我们才能更进一步的修改框架来定制化更复杂更贴合项目要求的各种组件，本文按照 由实用到进阶再到研究源码 的思路为各位研究框架源码提供另一种方法。下一步将会在vant-weapp弹框组件之上封装一系列实战的案例，期待你的关注与收藏。若此文对你有一点点帮助请点个赞鼓励下作者，毕竟原创不易:)首发自语雀： www.yuque.com/johniexu/fr…作者博客地址： blog.lessing.online/作者github： github.com/johniexu", "pub_time": "2020-2-26 00:33", "author": "Rolan"}
{"title": "小程序-日历签到 ", "content": "看小效果哈\r\n\r\n首先，我们要获取的无非就是每一个格子里面的数据。\r\n先获取月，然后点击月切换到另一个月，到了边界线的时候到了上/下年即可。\r\n那么，怎么获取月的数据呢，可以看到月第一天都是1开始，然后xx天，比如1月31天，我们把它枚举出来。\r\n但是月份受到年份影响，所以计算是否闰年就完成了。\r\n上代码\r\n获取这个月的7*5列表\r\nlet getMothList = (year, month) => {\r\n    var star = new Date(Date.UTC(year, month - 1, 1)).getDay()\r\n    let mn = getMothNum(year)[month - 1]\r\n    var res = []\r\n    var row = []\r\n    new Array(35)\r\n        .fill('')\r\n        .map((_, i) => i - star + 1)\r\n        .map(e => \r\n            (e > 0 && e <= mn)\r\n            ? ({\r\n                date: `${year}/${month}/${e}`,\r\n                number: e \r\n            })\r\n            : (null)\r\n        )\r\n        .forEach((item, i) => {\r\n            row.push(JSON.parse(JSON.stringify(item)))\r\n            if((i + 1) % 7 == 0){\r\n                res.push(row)\r\n                row = []\r\n            }\r\n        })\r\n    return res\r\n}\r\n复制代码然后获取月\r\nvar getMaxY = y =>  Boolean(\r\n\ty % 4 ==0 && y % 100 != 0 || y % 400==0\r\n)\r\nvar getAugNum = n => getMaxY(n) ? 29 : 28\r\n// --获取年对应的月份\r\nvar getMothNum = y => ([ 31, getAugNum(y), 31, 30,  31, 30, 31,31, 30, 31, 30, 31 ])\r\n复制代码我上面js就这些了（还差上下月切换的没说哈）\r\n但是少了中文的月份，有需要的这个可以再匹配\r\nvar mothZh = ['一','二','三','四','五','六','七','八','九','十','十一','十二'].map(e => e + '月')\r\n复制代码然后就是上下月月份了\r\n\r\n  up(e){\r\n    var data = e.currentTarget.dataset\r\n    if(data.data == '上'){\r\n      if(this.data.dateM > 1){\r\n        var dateM = this.data.dateM\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY, dateM - 1)\r\n      }else{\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY - 1, 12)\r\n      }\r\n    }\r\n  },\r\n  down(e){\r\n    var data = e.currentTarget.dataset\r\n    if(data.data == '下'){\r\n      if(this.data.dateM < 12){\r\n        var dateM = this.data.dateM\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY, dateM + 1)\r\n      }else{\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY + 1, 1)\r\n      }\r\n    }\r\n  },\r\n复制代码上下月操作好了就是更新数据了，更新数据的时候，因为小程序不能在view里面写逻辑，所以我们在mpa里面操作（这是我的业务逻辑，你们不用管他，我之所以放出来是方便大家查看）\r\n  setDate(dateY, dateM){\r\n    var date_list = getMothList(dateY, dateM)\r\n    .map(e => !e ? e : e.map(day => {\r\n      var cat_date = this.data.cat_date\r\n      return !day ? day : {\r\n        ...day,\r\n        className: this.data.chckin_list.indexOf(day.date) != -1 ? 'checkin' : '',\r\n        sign: day.date == [cat_date.y, cat_date.m, cat_date.d].join('/'),\r\n        maxToday: +(Date.UTC(day.date.split('/')[0], day.date.split('/')[1] - 1, +(day.date.split('/')[2])))\r\n          > Date.UTC(new Date().getFullYear(), new Date().getMonth(), new Date().getDate()),\r\n      }\r\n    }))\r\n    this.setData(({\r\n      dateY,\r\n      dateM,\r\n      date_list,\r\n    }))\r\n    // 获取月和修改的时候，获取签到列表\r\n    this.setSign(dateY, dateM)\r\n    // console.log(date_list)\r\n  },\r\n复制代码然后会注意到，这里有一个chckin_list，这个就是要渲染出来的啦。\r\nview\r\n<view class=\"week\">\r\n            <view class=\"flex\" wx:for=\"{{date_list}}\" wx:key=\"index\" wx:for-item=\"row\">\r\n                <view \r\n                class=\"day {{day.maxToday ? 'maxToday' : ''}}\" \r\n                wx:for=\"{{row}}\" wx:for-index=\"row_idx\" wx:for-item=\"day\" wx:key=\"row_idx\"\r\n                bind:tap=\"tapDay\"\r\n                data-day=\"{{day.date}}\"\r\n                >\r\n                    <block wx:if=\"{{day}}\">\r\n                        <text class=\"block to_day_block  {{day.sign ? 'select_date' : ''}}\" wx:if=\"{{toDay == day.date}}\">今</text>\r\n                        <text class=\"block  {{day.sign ? 'select_date' : ''}}\" wx:else>{{day.number}}</text>\r\n                    </block>\r\n                    <view wx:if=\"{{day.className}}\" class=\"{{day.className}}\">已签</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n复制代码上面是我的业务逻辑，其实只需要if，day就行了，因为除了空的，其他都需要渲染。但是一般业务也有是否签到啊，今天以后的灰色不可点击啊（这里没有不可点击是因为用css禁用点击）\r\n其他\r\n之所以没放css，大家css还是自己写吧，如果真有需要，在下面评论。\r\n哦， 如果要看效果，去小程序里面搜索，《初九背单词》，点击日历（一个是首页完成今日任务，一个是我的->背单词天数）\r\n（如果有需要，我可以说下签到后台是怎么做的，nodejs）\r\n--好了--\r\n就这样了，晚安", "pub_time": "2020-2-26 00:43", "author": "Rolan"}
{"title": "写了一个小程序——无聊也是一种生产力 ", "content": "​无聊也是一种生产力，最近不止无聊，还心烦，这种情况我只会做三种事情会比较开心，和某人出去玩、打游戏或者是写代码，前两种由于现实情况没办法实现，我就只能采用第三种方法了，并且这种时候写代码总可以写点自己想做的东西。小程序，很久之前写了一个非常简单的，当时就觉得微信小程序原生的语法真是的太复杂限制太多还不好用，尤其像我这种人，做出来的东西真的是丑的要死。这一次当然不会从头来了，果断 GitHub 找一找，不出所料，找到了我想做的东西的模板，甚至更应该说找到了还算不错的项目，Gitter，这是一个号称最漂亮的 GitHub 微信小程序，我表示同意，但是用着用着，发现其实有一点问题，无法满足我的需求：他的项目中 README 显示直接宕机了，不能显示 README 了，这个影响有点大，后来我看代码，猜测的原因是他把 markdown 的解析放到了服务器上，服务器挂掉了或者什么其他原因吧。打开小程序显示的就是 GitHub Trending，这个功能不错，但是在 Trending 中找到感兴趣的项目效率其实还是有点低的，很多时候我进去是看最近最火的现象级的项目是什么，比如 996.ICU，wuhan2020 这种，这个需求没有得到很好的满足。用这个小程序提 issue 的时候会自动加上一个小尾巴，内容是 Gitter 小程序的二维码，这个功能可以让使用者帮忙推广 小程序，没问题也是不错的方法，但是如果在一个 issue 下反复评论多次出现， 就会有一点重复的感觉。总的来说，这个小程序是一个很优秀的小程序，作为学习者的我，我要向其看起，针对不能满足需求的部分，那我就自己改写吧，License 是 Apache License 2.0，改写没问题。这里不想写具体的实现代码，如果有兴趣请 点击查看 改写后的项目，这里给出两张最后的截屏效果图吧：打开小程序，你第一眼看到的可能就是最近最应该知道的一个小程序（选择依据是积极、健康、热点、具有一定进步性，人工审核），本小程序可以查看自己所 Follow 人的活动，如果感兴趣也可以很方便的 star 或 fork，也可以查找 GitHub 所有的项目或用户（Gitter 中本来是有这个支持计划的，但是不知道为什么去掉了，我在近一周的平时使用多次用到了这个功能，还是很实用的），还可以分享给朋友，也支持 在公众号中插入直接跳转到某一个项目，在本篇中前后就有两个例子 ，非常欢迎大家使用，对于小尾巴，我的做法是可选而不是强制，为我宣传，我很感激，但是仅仅作为工具不强迫你。对于 README显示前三千个字符，基本应该可以了解这个项目是用来做什么的了，如果想查看全文可以到 Code 中查看，也是格式化好的，但是这样做就可以放在本地，并且有很好的效率，网络下载成功后几乎不用等待，我认为这样是一个比较好的用户体验。其他的界面我也都做了很多的相应优化，一些小细节，希望可以让你使用起来觉得还不错吧。开始这个项目时，由于我对小程序的写法，尤其是 Taro（本项目使用的一个框架）是从完全没听过的状态开始这个项目的，因此参考拷贝了大量的 Gitter 中代码，本项目是对 Gitter 项目的拙劣模仿。特此感谢！Gitter 项目可点击查看： Gitter后记：每次闲下来无聊我都会围绕 GitHub 学东西，这一次自我感觉是写关于 GitHub 最成功的一次了，原因也是因为这次时间最长，无聊就是生产力呀！武汉加油！中国加油！首发自公众号： RAIS", "pub_time": "2020-2-27 00:34", "author": "Rolan"}
{"title": "玩转微信小程序的位置授权 ", "content": "背景\r\n日渐增多的小程序需求，必然会存在形色各异的授权问题。今天就来跟大家一起学习一下如何玩转小程序的位置授权\r\n位置授权问题分类\r\n\r\n并非必须允许授权：在第一次用户决策完成后都允许用户继续操作（并非完全依赖位置信息）\r\n必须允许授权：只有授权才能使用（依赖位置信息的wx小程序）\r\n\r\n分类剖析\r\n1.针对需求分类1的情况，在这里就不多说，直接调用wx.getLocation就可以\r\n2.只有授权才能继续使用的情况\r\n\r\n\r\nApp:用于描述整体程序，需要对应用添加地理位置授权，代码如下App({\r\n    config: {\r\n        'permission': {\r\n          'scope.userLocation': {\r\n            'desc': '请开启位置授权' // 高速公路行驶持续后台定位\r\n          }\r\n        },\r\n    }\r\n})\r\n复制代码\r\nPage: 处理位置信息的页面或者区域\r\nwx.getLocation: 不多讲解，是小程序的api，使用方法以及实现效果如下 Page({\r\n     onLoad () {\r\n         wx.getLocation({\r\n             success: (res) => {}, // 成功的回调\r\n             fail: (err) => {} // 失败的回调\r\n         })\r\n     }\r\n })\r\n复制代码\r\n\r\n\r\n\r\n\r\n$invoke('LocationAuthModal', showModal): 通过对LocationAuthModal组件中的方法直接调用，在页面中弹出提示弹窗，效果如下（LocationAuthModal组件是我们自定义的弹窗，并且在页面中引用）\r\n\r\n\r\n\r\nButton(open-type=”openSetting”  bindopensetting=callback): 小程序基础库2.3.0版本开始，用户发生点击行为后，才可以跳转打开setting页面，管理设置授权信息。在完成设置后，在callback中获取到授权auth进行处理：\r\n<button  open-type=\"openSetting\" @opensetting=\"callback\">设置</button>\r\n复制代码\r\n\r\ncallback: 设置完成后的回调函数\r\n\r\n\r\nsetting: 小程序的设置\r\n\r\n\r\nauth: 设置完成后获取到的设置授权信息\r\n\r\n\r\nauth[“scope.userLocation”] = true：开启了位置授权的设置，可以直接通过wx.getLocation拿到位置信息\r\n\r\n\r\nelse: 仍未开启位置授权，那么根据我们的需求是不能继续让用户使用的，所以会继续执行$invoke('LocationAuthModal', showModal)，强制提醒用户开启位置授权\r\n\r\n\r\nsuceeCallback: 成功获取位置后的回调函数，用来处理获取到微信知悉后的操作\r\n\r\n\r\n说明\r\n\r\n文档中的部分代码采用微信小程序框架--wepy\r\n开发过程中使用小程序基础库版本为v2.10.1", "pub_time": "2020-2-27 00:52", "author": "Rolan"}
{"title": "控制音频文件播放进度 ", "content": "问题描述在微信小程序中经常会用到控制文件播放的滑块，通过滑块可控制音频播放进度，下面即用代码实现。解决方案首先用.wxml与.wmss代码实现进度条的效果，再通过.js文件控制进度条的进度和进度条的时间显示。.wxml中(播放进度结构的代码)：<view class=\"content-play-progress\">  <text>{{play.currentTime}}</text>    <view>      <slider activeColor=\"#d33a31\" block-size=\"12\" backgroundColor=\"#dadada\" value=\"{{play.percent}}\"/>    </view>  <text>{{play.duration}}</text></view>在上述代码中，第五行用到了slider组件，其值为播放进度play.percent。.wxss中(播放进度样式的代码):.content-play-progress{  display: flex;  align-items: center;  margin: 0 35rpx;  font-size: 9pt;  text-align: center;}.content-play-progress>view{  flex: 1;}保存上述代码后，运行程序，效果如图：图 1 微信小程序进度条的实现.js中(控制进度条的进度和时间的代码):onReady: function(){  this.audioCtx=wx.createInnerAudioContext()  var that=this//播放失败检测this. audioCtx.onError(function(){    console.log(‘播放失败：’+that.audioCtx.src)})//播放完成自动换下一曲this. audioCtx.OnEnded(function(){  that.next()})//自动更新播放进度this. audioCtx.onPlay(function(){this. audioCtx.onTimeUpdate(function(){  that.setData({‘play.duration’: formatTime(that.audioCtx.duration),‘play.currrentTime’: formatTime(that.audioCtx. currrentTime),‘play.percent’: that.audioCtx. currrentTime /            that.audioCtx.duration*100})})//默认选择第一曲 This.setMusic(0)  //格式化时间function formatTime(time){   var minute=Math.floor(time/60)%60;var second=Math.floor(time)%60return (minute<10?’0’+minute:minute)+’:’+     (second<10?’0’+second:second)}})}上述代码中，通过调用audioCtx的onTimeUpdate()的方法，获取音视频状态信息，并通过formatTime()函数处理时间格式，最后渲染到页面实现实时更新效果，效果如图：图 2 微信小程序进度条的滑动在slider组件上绑定bindchange事件，可以实现滑动进度条调节音视频文件播放进度，代码示例:<slider bindchange=”sliderChange” activeColor=”#d33a31” block-size=”12” backgroundColor=”#dadada” value=”{{play.percent}}”/ >在.js文件中编写sliderChange函数获取用户当前选择的进度，将时间通过audioCtx对象的seek()方法进行设置，代码示例：sliderChange: function(e){  var second=e.detail.value* that.audioCtx.duration/100that.audioCtx.seek(secend)},", "pub_time": "2020-2-28 00:02", "author": "Rolan"}
{"title": "这次一定彻底弄懂DOM事件机制 ", "content": "本文首发自 JohnieXu's Blog ，转载请注明出处:grin:前言在网页端、移动端H5、小程序等各个终端环境的前端开发中随处可见事件的运用，可见事件机制的是前端这一块的重中之重。经过我研读了大量博客文章以及开源框架源码后，这次算是对DOM事件机制有了更新更全面的的认识。下文主要通过一个例子带你 分析DOM事件的传递、事件处理 ，然后在此基础上再 深入总结对事件监听的优化方案 ，最终总结下DOM事件机制 在开源框架中的实战应用 。一、从实例看事件传递以下面这个普通的html文件为例<!DOCTYPE html>\r\n<html lang=\"en\" onclick=\"handleClickHtml()\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Document</title>\r\n</head>\r\n<body onclick=\"handleBodyClick()\">\r\n  <div id=\"div1\" onclick=\"handleClick2()\">\r\n    <button id=\"button1\" onclick=\"handleClick1()\">handleClick1</button>\r\n  </div>\r\n  <script>\r\n    function handleClick1(e) {\r\n      console.log('click1')\r\n    }\r\n    function handleClick2(e) {\r\n      console.log('click2')\r\n    }\r\n    function handleBodyClick(e) {\r\n      console.log('body clicked')\r\n    }\r\n    function handleClickHtml(e) {\r\n      console.log('html clicked')\r\n    }\r\n    document.addEventListener('click', e => {\r\n      console.log('document clicked')\r\n    })\r\n  </script>\r\n</body>\r\n</html>\r\n复制代码例子中给 document、html、body、div、button 都添加了点击事件，其执行结果如下：执行结果事件传递事件产生后，从window对象自上而下向目标节点传递，抵达目标节点后会沿着相反方向传递DOM事件传递事件传递路径如何确定？由鼠标、键盘、触摸屏、窗口缩放、图片加载、节点焦点变化等触发事件，每个触发的事件都有一个target——事件目标，根据target往html根节点遍历就可以确定节点嵌套层级关系，从而确定此事件的传递路径。事件传递路径由浏览器、webview来确定事件传递为何要来回走两遍？一个事件来回走两遍是便于事件响应时机的控制（下文的事件冒泡与事件捕获的应用中有体现），同时也存在事件冒泡的浏览器历史原因（与IE、Netscape有关，不赘述）。事件响应事件在从自上而下的传递过程中会 判断当前node节点是否绑定对应事件的监听器 ，若有则执行响应监听器的事件处理程序（也就是绑定的事件要执行的逻辑），这里的执行就是所谓的事件响应。事件的响应过于与事件的类型是捕获事件、冒泡事件有关，同时是否组件冒泡还会影响该事件的后续传递过程，具体执行流程总结成如下图所示：事件响应逻辑事件捕获与冒泡根据事件传递中的两种传递路径分别分为： 由上至下——事件捕获阶段，由下至上——事件冒泡阶段 ，指的是一个事件由window（上图并未标出window）到target之间的传递的过程。可以通过组织事件冒泡让事件不再继续完成由下至上的过程，这会让target的父节点绑定冒泡阶段的事件监听器不响应事件。可以通过指定事件在捕获阶段执行。:chestnut:冒泡的应用看下面这个例子，可以通过 stopPropagation 来阻止事件继续往上冒泡， window、document、html 上添加的点击事件均不会生效<!-- 省略了部分代码 -->\r\n<div id=\"div1\">\r\n  <button id=\"button1\">button</button>\r\n</div>\r\n<script>\r\n  var div1 = document.getElementById('div1')\r\n  var button1 = document.getElementById('button1')\r\n  div1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n  }, false)\r\n  button1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n    e.stopPropagation() // 关键代码：组织了click事件继续往上冒泡\r\n  }, false)\r\n复制代码// 以下是监听html、document的点击事件 function handleClickHtml(e) { console.log('html clicked') } document.addEventListener('click', e => { console.log('document clicked') }) </script> 复制代码点击button的打印结果如下：执行结果addEventListener需要用attachEvent进行兼容性处理，第三个参数默认值为false表示在事件冒泡阶段响应事件:chestnut:捕获的应用还是上面这个例子，只更改div1部分的事件监听，的第三个参数为true来开启事件捕获<!-- 省略了部分代码 -->\r\n<div id=\"div1\">\r\n  <button id=\"button1\">button</button>\r\n</div>\r\n<script>\r\n  var div1 = document.getElementById('div1')\r\n  var button1 = document.getElementById('button1')\r\n  div1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n  }, true) // true：表示div1在事件的捕获阶段响应事件\r\n  button1.addEventListener('click', (e) => {\r\n    console.log(e.currentTarget)\r\n    e.stopPropagation() // 组织事件冒泡\r\n  }, false)\r\n复制代码// 以下是监听html、document的点击事件 function handleClickHtml(e) { console.log('html clicked') } document.addEventListener('click', e => { console.log('document clicked') }) </script> 复制代码点击button的打印结果如下：执行结果依次执行了div1和button1绑定的点击事件，注意这里两者的 执行顺序 很关键。事件在捕获阶段遇到div1节点时执行打印，然后在button处（处于目标阶段）执行打印，然后事件被阻止冒泡不再往上传递。二、事件性能优化大批量事件监听性能问题考虑以下场景：有个一个长消息列表实时接受新的消息，滚动到底部时加载更多消息，点击消息可进入回话窗口页面，消息左滑消息此条消息问题：如何给此消息列表添加左滑事件？抽象来看这个问题就是如何高效的给大批量（甚至是无限量）节点添加事件，这里暂时不考虑vue、react等框架性能问题原因每注册一个事件监听监听都需要使用一定内存，同时在dom节点多了之后事件经过的捕获、冒泡阶段要处理事件传递也就慢了事件委托父节点嵌套的子节点的触发的事件会通过事件冒泡到达父节点，事件处理程序不直接绑定到子节点，统一由公共父节点进行事件监听。e.target表示触发事件的元素，通过e.target可以判断具体响应那个元素的事件 e.currentTarget表示事件绑定的元素，在事件委托情况下指向同一个元素事件委托采用事件委托改造本文例子<!-- 省略了部分代码 -->\r\n<div id=\"div1\">\r\n  <button id=\"button1\">button</button>\r\n</div>\r\n<script>\r\n  document.addEventListener('click', e => {\r\n    // e.target：触发事件的元素\r\n    // e.currentTarget：事件监听器绑定的元素\r\n    // console.log(e.target, e.currentTarget)\r\n    if (e.target.id === 'button1') {\r\n      return console.log('button1 clicked')\r\n    }\r\n    if (e.target.id === 'div1') {\r\n      return console.log('div1 clicked')\r\n    }\r\n    if (e.target.tagName === 'HTML') {\r\n      return console.log('html clicked')\r\n    }\r\n    if (e.target.tagName === 'BODY') {\r\n      return cosnole.log('body clicked')\r\n    }\r\n  })\r\n</script>\r\n复制代码依次点击 html、div1、button1 会依次打印结果：执行结果虚拟滚动上面事件委托可以解决大批量节点事件监听的性能问题，但是DOM节点量过大导致界面滚动不流畅的问题没解决。虚拟滚动是指在列表滚动事件中动态计算出当前窗口中能够显示的列表节点，其前后窗口不显示的节点各用一个div进行占位处理，并调整占位div的样式确模拟的列表样式与原始列表无异处。虚拟滚动已经是一个完美解决长列表渲染性能的方案，针对react、vue均有对应库实现，此处不再赘述React事件代理事件委托也叫事件代理，在react中的合成事件则是完全采用了事件代理基于react16的 ant-design-pro 项目的事件绑定截图如下：React事件代理直接通过onClick绑定的事件通过react处理最终会统一绑定到document上，正是使用的事件委托。三、实战中的应用小程序中阻止事件冒泡阻止弹窗滚动穿透最新版微信小程序中绑定事件有两种类型： bind:methodName、catch:methodName、mut-bind:methodName、mut-catch:methodName ，其中区别最大的是前两者。methodName表示移动端事件名，例如：tap、touchmove等bind:methodName 采用冒泡绑定事件， catch:methodName **采用冒泡绑定事件并阻止冒泡vant-weapp中防止滚动穿透实现思路： 弹框采用一层遮罩层overlay遮盖，遮罩层宽高设为窗口宽高同大小，采用 catch:touchmove 绑定该层的touchmove事件为空函数防止其冒泡 。给overlay组件外层绑定touchmove为空函数并阻止冒泡：// overlay/index.wxml\r\n<van-transition\r\n  show=\"{{ show }}\"\r\n  custom-class=\"van-overlay\"\r\n  custom-style=\"z-index: {{ zIndex }}; {{ customStyle }}\"\r\n  duration=\"{{ duration }}\"\r\n  bind:tap=\"onClick\"\r\n  catch:touchmove=\"noop\"\r\n  /*\r\n   * 通过catch:touchmove来阻止冒泡至overlay层的事件继续往上冒泡，\r\n   * 实现内层嵌套的内容可以响应touchmove事件而外层（页面）滚动事件不响应），\r\n   * 以此来解决滚动事件穿透\r\n  */\r\n>\r\n  <slot></slot>\r\n</van-transition>\r\n复制代码overlay组件外层fixed定位固定宽高防止滚动：// overlay/index.less\r\n.van-overlay {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  .theme(background-color, '@overlay-background-color');\r\n}\r\n复制代码移动端H5框架中事件冒泡阻止弹窗滚动穿透vant中防止滚动穿透实现思路：与vant-weapp小程序框架中相似， 弹框采用一层遮罩层overlay遮盖，遮罩层宽高设为窗口宽高同大小，采用 @touchmove 绑定该层的touchmove事件，在事件中用event.stopPropagation阻止事件冒泡 。给overlay组件外层绑定touchmove事件阻止冒泡：return (\r\n  <transition name=\"van-fade\">\r\n    <div\r\n      vShow={props.show}\r\n      style={style}\r\n      class={[bem(), props.className]}\r\n      onTouchmove={preventTouchMove}\r\n      {...inherit(ctx, true)}\r\n    />\r\n  </transition>\r\n);\r\n复制代码const preventTouchMove(e: Event): void = () =&gt; { event.stopPropagation(); } <span>复制代码</span>overlay组件外层fixed定位固定宽高防止滚动：.van-overlay {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  .theme(background-color, '@overlay-background-color');\r\n}\r\n复制代码参考文章MDN-事件参考浪里行舟-DOM事件机制CSDN-事件冒泡（IE事件流），事件捕获和DOM事件流写在最后既然看到这里不妨点个赞鼓励下作者呗 :)作者博客： blog.lessing.online/作者github： github.com/johniexu", "pub_time": "2020-2-28 00:32", "author": "Rolan"}
{"title": "微信小程序的自动化测试框架 ", "content": "微信发布了小程序的自动化测试框架Minium，提供了多种运行验证方式，其特点：支持一套脚本，iOS & Android & 模拟器，三端运行提供丰富的页面跳转方式，看不到也能去得到可以获取和设置小程序页面数据，让测试不止点点点可以直接触发小程序元素绑定事件支持往 AppSerive 注入代码片段可以调用部分 wx 对象上的接口官方地址如下： https://git.weixin.qq.com/min...minium 是为小程序专门开发的自动化框架, 提供了 Python 和 JavaScript 版本。使用 minium 可以进行小程序 UI 自动化测试, 但是 minium 的功能不止于仅仅是 UI 自动化, 甚至可以使用 minium 来进行函数的 mock, 可以直接跳转到小程序某个页面并设置页面数据, 做针对性的全面测试, 这些都得益于我们开放了部分小程序 API 的能力。除此之外，小程序有部分组件使用了系统原生的组件，对于这部分的组件，我们也基于 uiautomator 和 wda 做了补充。环境依赖Python 3.x微信公共库版本 >= 2.7.3下载并安装稳定版微信开发者工具，工具下载地址： https://developers.weixin.qq....如果要测Android，请下载微信测试包，下载地址： http://dldir1.qq.com/weixin/a...文档使用Minium的文档是采用Nodejs编写的，因此想看文档还需要安装NodeJs的环境，如果你不知道怎么安装请自行查找。文档的安装：npm i docsify-cli -g然后checkout文档项目：git clone https://git.weixin.qq.com/minitest/minium-doc安装依赖：cd minium-doc\r\nnpm install本地部署：docsify serve .然后通过浏览器访问 http://localhost :3000 即可以查看了。框架依赖运行环境部署首先你要先下载框架压缩包： https://git.weixin.qq.com/min...接下来，你要打开微信开发者工具的安全模式然后安装Minium:pip3 install minium-0.0.2.zip使用首先你要通过命令行启动开发者工具提供了命令行命令行通过命令行调用安装完成的工具可执行文件，完成登录、预览、上传、自动化测试等操作。调用返回码为 0 时代表正常，为 -1 时错误。命令行工具所在位置：macOS: <安装路径>/Contents/MacOS/cli\r\n\r\n   Windows: <安装路径>/cli.bat命令行启动工具-o, --open [projectpath]: 打开工具，如果不带 projectpath，只是打开工具。如果带 project path，则打开路径中的项目，每次执行都会自动编译刷新，并且自动打开模拟器和调试器。projectpath 不能是相对路径。项目路径中必须含正确格式的 project.config.json 且其中有 appid 和 projectname 字段。示例：# 打开工具cli -o# 打开路径 /Users/username/demo 下的项目cli -o /Users/username/demo输入如下命令：path/to/cli --auto /miniprogram/project/path --auto-port 9420\r\n\r\n# path/to/cli 是命令行工具所在位置：\r\n# macOS: <安装路径>/Contents/MacOS/cli\r\n# Windows: <安装路径>/cli.bat windows版本在安装之后默认会把cli加入到系统路径，可以先测试cli命令是否可用，如果可用，path/to/cli可以直接用cli替换\r\n\r\n# /miniprogram/project/path 是小程序工程的路径( Windows下面用 \\\\ 代替 \\ )特别说明：1、这里的--auto-port请填写 9420，不是开发者工具安全模式的端口2、请确保开发者工具登陆的微信号具备被测小程序的开发者权限3、如果没有Open project with automation enabled success的输出，否则请检查IDE版本（开发者工具调试基础库版本 >= 2.7.3），或者检查命令行参数关注我，关注测试", "pub_time": "2020-2-5 00:52", "author": "Rolan"}
{"title": "小程序如何写动态标签 ", "content": "web开发中，尤其使用react开发项目时，我们可以很方便的动态定义标签(jsx)const props = {\r\n  id: '',\r\n  className: '',\r\n  data-a: ''\r\n}\r\n<button {...props} />\r\n复制代码动态配置标签的好处一是所有逻辑在JS端控制，二是使得我们的模板非常规范，方便后续维护更新，碎片模板可以很好的控制，三是我们可以根据使用场景很方便的配置props的属性，这样在html结构输出的时候能够得到比较干净的结构在小程序的开发中，却不能实现类似的功能，导致我们的动态标签通常非常的冗余，多余的属性全部展示在结构生成后以button为例，我们知道button在小程序中有非常多的属性如上所示，这里只是列举了一部分的属性动态模板我们的button动态模板写下来应该是这样的配置Page({\r\n  data: {\r\n    option: {\r\n      ...\r\n    }\r\n  }\r\n})\r\n复制代码<button\r\n  size=\"{{option.size || 'default'}}\"\r\n  type=\"{{option.type || 'default'}}\"\r\n  plain=\"{{option.plain || false}}\"\r\n  value=\"{{option.value || '按钮'}}\"\r\n  ...\r\n  ...\r\n/>\r\n复制代码调试工具的输出结构<button bindtap='' size='' type='' plain='' disabled=false open-typ='' hover-class='' .... />\r\n复制代码可以看到调试工具中输出的结构就会变得非常冗余，降低了开发效率，这种冗余的模板输出搞久了会吐的好吧。可以使用模板语法区分不同场景的button，我知道会有很多这样的声音，但那不是动态模板。解决问题那要如何解决输出结构不冗余呢，说了这么多终于到了重点，其实真的只是一个很小的技巧，我的开发经历告诉我这是有效的，你也可以试试，将默认值统统换成 '' ，改版后的模板如下<button\r\n  size=\"{{option.size || ''}}\"\r\n  type=\"{{option.type || ''}}\"\r\n  plain=\"{{option.plain || ''}}\"\r\n  value=\"{{option.value || '按钮'}}\"\r\n  ...\r\n  ...\r\n/>\r\n复制代码这时你得到的模板就是一段漂亮的结构<button value='按钮' />\r\n复制代码", "pub_time": "2020-2-6 00:14", "author": "Rolan"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。", "pub_time": "2016-10-12 22:14", "author": "admin"}
{"title": "微信小程序周边配套的实现 ", "content": "一 需求分析：以该小区为中心，实现周边配套的检索，切换不同种类的检索条件，刷新页面，并以气泡的方式显示出来，效果如下~二 实现方式：底部我是用的vant组件的tabbar来实现切换显示 下载微信小程序JavaScriptSDK 引入SDK，并且实例化API核心类var QQMapWX = require('../../../libs/qqmap-wx-jssdk.js')var app = getApp()// 实例化API核心类var qqmapsdk = new QQMapWX({  key: app.globalData.map_key // 必填});当切换底部标签时，获取要搜索的关键字，调用接口，实现搜索// 事件触发，调用接口  nearby_search: function() {    var _this = this;    // 调用接口    qqmapsdk.search({      keyword: _this.data.kewWord, //搜索关键词      location: {        latitude: _this.data.lat,        longitude: _this.data.lng      }, //设置周边搜索中心点      success: function(res) { //搜索成功后的回调        var mks = []        //在此将小区的位置坐标点加载出来        mks.push({          latitude: _this.data.lat,          longitude: _this.data.lng        })        for (var i = 0; i < res.data.length; i++) {          mks.push({ // 获取返回结果，放到mks数组中            title: res.data[i].title,            id: res.data[i].id,            latitude: res.data[i].location.lat,            longitude: res.data[i].location.lng,            iconPath: _this.data.img, //图标路径            width: 24,            height: 28,            callout : {              color : \"#fff\",              padding : 8,              content: res.data[i].title,              borderRadius : 5,              bgColor: \"#3072f6\",              fontSize : 12            }          })        }        _this.setData({ //设置markers属性，将搜索结果显示在地图中          markers: mks        })      },      fail: function(res) {        console.log(res);      },      complete: function(res) {        console.log(res);      }    });  },到这里基本上就实现了周边配套的需求，现在你需要做的不过是，规整一下整体逻辑和交互，当点击图标会出现气泡框，具体气泡的显示方式参照微信小程序的map组件即可作者：DevinZ", "pub_time": "2019-10-24 00:50", "author": "Rolan"}
{"title": "写给小程序开发者的“一大堆”建议 ", "content": "从工作到现在，我已经累计写了超过6个小程序，总结以及探索到了许多便于开发的解决方案，在这里分享给大家。编码规范缘由编码规范应放在首位。当一个项目需要多个人同时进行编码时，编码规范尤为重要，当我看见我编写的代码里被其他人写的其他风格的代码“污染”了时，那感觉像吃了屎一样。这就是为什么我要求团队有一个统一的代码规范，这会极大地提升代码的可读性，以及协同开发的开发效率。不过现实是，即便开发之前已经订好了规范，总有人在不经意间去在项目里“大展拳脚”，体现自己的独特性，这个时候就需要代码review了。在国外，开发工作并不是最繁琐的，最繁琐的是代码review，Google、Microsoft这些建立在代码上的“帝国”都有一套成熟完善的代码review机制，这足以说明对于建立在代码上的“帝国”而言，编码规范在某种程度上就相当于法律，严酷的惩罚将每个开发人员的“邪念”压制住，这是我们应该了解和学习的。规范文件命名：文件及文件夹统一使用下划线命名，比如\tgoods_detail.wxml ，不使用中横线的原因是其严重影响可读性。组件命名：组件统一使用首字母驼峰命名，比如\tNavBar.wxml ，使用首字母驼峰的原因是组件在页面中是一类特殊元素，需要明显的标识让它与其他便签或方法区别开来。变量命名：变量统一使用下划线命名，比如\tgoods_coupon ，对于方法内的特殊私有变量，使用下划线开头，比如\tconst _that = this ，对于系统级别的变量，采用大写下划线命名，比如\tMAX_VALUE 。方法命名：方法统一使用驼峰命名，比如\tGetUserInfo ，私有方法使用下划线开头的驼峰命名，比如\t_onClose ，在wxs文件中定义的全局方法使用大写的下划线命名，比如：\tFORMAT_PRICE 。其他：在js文件中，省略语句后面分号，提升可读性。对于使用次数不超过两次的值，不单独设置变量。在方法中，对于不同类型的语句，使用空行分隔，便于阅读。CSS属性排列顺序为：绝对定位>flex定位>float定位>width/height>padding/margin>border>background>font相关>特殊属性。更多内容请参照这篇文章：大前端团队代码规范借助wxss-cli在小程序中使用less安装win\tnpm i wxss-cli -gmac\tsudo npm i wxss-cli -g使用使用终端（CMD）进入到项目目录，执行\twxss . ，\t. 表示当前目录。即可看到less文件将被编译成同名的wxss文件。使用CSS原生变量场景有时候我们与一些不适用less进行开发的小伙伴进行协同，需要统一变量，这个时候CSS原生变量就派上了用场。定义app.wxsspage{\r\n    --color_main:#333333;\r\n    --color_sub:#555555;\r\n}\r\n复制代码使用index.wxss@import '../app.wxss';\r\n\r\n.section .title{\r\n    color:var(--color_main);\r\n}\r\n\r\n.section .content{\r\n    color:var(--color_sub);\r\n}\r\n复制代码使用defineProperty定义app.globalData 构建全局数据中心缘由有时，我们会遇到一些很特殊的需求，比如需要在自定义的tabbar上与页面进行交互，而微信的自定义tabbar又没法使用triggerEvent（在页面里不需要引用tabbar），这个时候就需要借助\tconst app = getApp() 来实现类似于数据中心的功能。现在的需求是，进入到购物车页面，选择完商品之后需要在tabbar上显示总的价格，然后点击tabbar上的付款按钮。那我们首先得拿到实时的购物车选中商品的数据，也就是做我们得监听购物车选中了哪些商品，同时在tabbar里面做出响应，这个时候，熟悉JS的同学就会想到defineProperty这个方法，它允许我们定义一个变量，同时提供get、set等钩子函数，类似于C#中的getter、setter方法。首先我们在app里定义这个变量，同时构建这个“数据中心”所需的“基础设施”：app.jsApp({\r\n    globalData:{\r\n        orders:[]\r\n    },\r\n    \r\n    // watcher start\r\n    watchCallBack: {},\r\n    watchingKeys: [],\r\n    initWatcher () {\r\n    \tthis.globalData$ = Object.assign({}, this.globalData)\r\n    },\r\n    setGlobalData (obj) {\r\n    \tObject.keys(obj).map((key) => {\r\n    \t\tthis.globalData[key] = obj[key]\r\n    \t})\r\n    },\r\n    watch$ (key, cb) {\r\n    \tthis.watchCallBack = Object.assign({}, this.watchCallBack, {\r\n    \t\t[key]: this.watchCallBack[key] || []\r\n    \t})\r\n    \r\n    \tthis.watchCallBack[key].push(cb)\r\n    \r\n    \tif (!this.watchingKeys.find((x) => x === key)) {\r\n    \t\tconst that = this\r\n    \t\tthis.watchingKeys.push(key)\r\n    \t\tObject.defineProperty(this.globalData, key, {\r\n    \t\t\tconfigurable: true,\r\n    \t\t\tenumerable: true,\r\n    \t\t\tset: function (val){\r\n    \t\t\t\tconst old = that.globalData$[key]\r\n    \t\t\t\tthat.globalData$[key] = val\r\n    \t\t\t\tthat.watchCallBack[key].map((func) => func(val, old))\r\n    \t\t\t},\r\n    \t\t\tget: function (){\r\n    \t\t\t\treturn that.globalData$[key]\r\n    \t\t\t}\r\n    \t\t})\r\n    \t}\r\n    },\r\n    // watcher end\r\n    \r\n)\r\n\r\n复制代码cart.jsonChangeOrders() {\r\n    const _that = this\r\n    \r\n\tapp.setGlobalData({\r\n\t\torders: _that.data.orders\r\n\t})\r\n}\r\n复制代码tabbar.jswatchOrders () {\r\n\tconst _that = this\r\n\r\n\tapp.watch$('orders', (new_val) => {\r\n\t\tif (new_val.length) {\r\n\t\t\t_that.setData({\r\n\t\t\t\torders: new_val\r\n\t\t\t})\r\n\t\t}\r\n\t})\r\n},\r\n复制代码了解更多请看这篇文章：\t50行代码监听watch小程序的globalData使用wxs文件定义模板filter缘由写过Vue的同学知道，在Vue里有一个特别方便的东西，就是filter，它可以很方便地处理模板变量，尤其是在循环数组时，但小程序并没有直接提供相关功能，其实我们可以借助小程序的wxs来实现（目前wxs对ES6的支持有限，许多高级特性都无法使用，比如Object、Array）。实现app.wxsmodule.exports = {\r\n\tFORMAT_PRICE: function (price){\r\n\t\tvar value = (price / 100).toFixed(2)\r\n\r\n\t\treturn value\r\n\t},\r\n\tFORMAT_ORDER_NUMBER: function (number){\r\n\t\tvar value = number.slice(0, 12)\r\n\r\n\t\treturn value\r\n\t},\r\n\tFORMAT_JSON_TO_STRING: function (string){\r\n\t\treturn JSON.parse(string)\r\n\t}\r\n}\r\n复制代码使用cart.wxml<wxs\r\n      src=\"../app.wxs\"\r\n      module=\"app\"\r\n/>\r\n\r\n<text class=\"price\">{{app.FORMAT_PRICE(item.price)}}</text>\r\n复制代码使用atom.css配合vs code插件IntelliSense for CSS class names in HTML快速出页面缘由由于小程序体积限制（2M），在小程序中基本上无法使用那种大而全UI框架，而这个时候CSS框架似乎是更好的选择，这里推荐使用\tatom.css 。安装npm i @verts/atom.css --save使用然后复制里面的\tatom-miniapp.min.wxss 文件到项目目录即可。如果要在less中使用，将\tatom-miniapp.min.wxss 更改为\tatom-miniapp.min.less 即可。配合vscode使用时需要安装\tIntelliSense for CSS class names in HTML ，并将atom.css项目文件夹引入到vscode中，让上述插件将atom.css的所有class缓存到vscode中（wxss 插件无法识别，故无法缓存）。效果使用async包装wx.request 简单实现拦截器的功能实现request.jsconst request = (url, method, data, header) => {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\twx.request({\r\n\t\t\turl: url,\r\n\t\t\tmethod: method,\r\n\t\t\tdata: data,\r\n\t\t\theader: Object.assign(\r\n\t\t\t\t{ token: wx.getStorageSync('token') },\r\n\t\t\t\theader\r\n\t\t\t),\r\n\t\t\tsuccess (res) {\r\n\t\t\t    //拦截器相关逻辑\r\n\t\t\t    if(res.code==='200'){\r\n\t\t\t        resolve(res.data)\r\n\t\t\t    }\r\n\t\t\t},\r\n\t\t\tfail (error) {\r\n\t\t\t\treject(error)\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n}\r\n\r\nexport const get = async (url, data) => {\r\n\treturn request(url, 'get', data)\r\n}\r\n\r\nexport const post = async (url, data, header) => {\r\n\treturn request(url, 'post', data, header)\r\n}\r\n\r\n复制代码使用import API from '../../utils/api'\r\nimport { get } from '../../utils/request'\r\n\r\nexport const Service_getGoodsDetail = (data) => get(API.API_getGoodsDetail, data)\r\n复制代码集中管理api接口缘由在项目进行的过程中，由于需求随时会产生变化，所以接口也可能会变化，这个时候就需要统一管理和配置接口，并保持接口的“无状态”，便于后期开发和维护。API命名格式为：\tAPI_[methodtype][Someone][Do][Something]实现api.js//线上地址\r\n// const API_BASE_URL = 'https://api.***.com'\r\n\r\n//测试地址\r\nconst API_BASE_URL = 'https://test.***.com'\r\n\r\n//开发地址\r\n// const API_BASE_URL = 'http://***:8080'\r\n\r\n//登录\r\nexport const API_postUserLogin = API_BASE_URL + '/***/login'\r\n\r\n//获取 用户信息\r\nexport const API_getUserInfo = API_BASE_URL + '/***/userInfo'\r\n\r\nconst API = {\r\n    API_postUserLogin,\r\n    API_getUserInfo,\r\n}\r\n\r\nexport default API\r\n复制代码使用mark对长列表做事件代理缘由过去我们使用Jquery，很容易通过on方法实现列表中的子项的操作进行代理操作，我们称之为事件委托。但在小程序中如何实现这一点呢？除了使用\tdata -，小程序提供给了我们一个比\tdata- 更加好用的方案——mark。使用coupon.wxml<view\r\n    class=\"coupon_items w_100 border_box flex flex_column\"\r\n    catchtap=\"onSelectCoupon\"\r\n>\r\n    <view\r\n          class=\"coupon_item w_100 border_box flex relative\"\r\n          wx:for=\"{{coupon_list}}\"\r\n          wx:key=\"{{index}}\"\r\n          mark:index=\"{{index}}\"\r\n    >\r\n        ***\r\n    </view>\r\n</view>\r\n复制代码coupon.jsonSelectCoupon(e){\r\n    const _that = this\r\n    const { index } = e.mark\r\n    \r\n    if(index){\r\n        _that.setData(\r\n            {\r\n                select_coupon_index:index\r\n            }\r\n        )\r\n    }\r\n}\r\n复制代码在setData之前对目标数据进行复杂操作const _that = this\r\nconst { index } = e.detail\r\n\r\n_that.data.coupon_list[index].selected = true\r\n_that.data.coupon_list[index].text_style = 'bold'\r\n\r\n_that.setData(\r\n    {\r\n        coupon_list:_that.data.coupon_list\r\n    }\r\n)\r\n复制代码使用recycle-view进行长列表渲染优化缘由之前做过一个新闻+购物的小程序，由于首页滚动列表的图片内容比较多，滚动加载很多条之后就会出现卡顿甚至直接卡出微信的情况，后来通过使用一些第三方的长列表优化插件优化了一下，至少不会直接卡出微信了，微信现在有一个官方的长列表优化方案，那就是revcycle-view，使用recycle-view能够极大地节省内存，同时提升用户体验，在angular7中，该功能已被集成到angular官方sdk中，而在react中，也有着很多虚拟滚动的方案，Facebook的Instagram Web端的PWA应用很多地方都用到了虚拟滚动。使用index.wxml<recycle-view\r\n            id=\"chosen\"\r\n            class=\"chosen w_100 border_box flex justify_between flex_wrap\"\r\n            batch=\"{{batchSetRecycleData}}\"\r\n            scroll-y=\"{{true}}\"\r\n            scroll-with-animation=\"{{true}}\"\r\n            lower-threshold=\"{{100}}\"\r\n            bindscrolltolower=\"onScrollToLower\"\r\n            enable-back-to-top=\"{{true}}\"\r\n            scroll-top=\"{{scroll_top}}\"\r\n            bindscroll=\"onScroll\"\r\n      >\r\n    <view\r\n          class=\"w_100 border_box flex flex_column\"\r\n          slot=\"before\"\r\n    >\r\n        ***\r\n    </view>\r\n    <view class=\"goods_card_items w_100 border_box flex justify_between flex_wrap\">\r\n          <recycle-item\r\n                class=\"goods_card_wrap\"\r\n                wx:for=\"{{recycleList}}\"\r\n                wx:key=\"{{item.__index__}}\"\r\n          >\r\n                <GoodsCard\r\n                      class=\"goods_card\"\r\n                      goods_id=\"{{item.goods_id}}\"\r\n                ></GoodsCard>\r\n          </recycle-item>\r\n    </view>\r\n</recycle-view>\r\n复制代码index.jsdata:{}\r\nrecycle_view_context:{},\r\ncreateRecycleView () {\r\n\tconst _that = this\r\n\r\n\tconst ctx = createRecycleContext({\r\n\t\tid: 'chosen',\r\n\t\tdataKey: 'recycleList',\r\n\t\tpage: _that,\r\n\t\titemSize: {\r\n\t\t\twidth: '100%',\r\n\t\t\theight: 350\r\n\t\t}\r\n\t})\r\n\r\n\t_that.recycle_view_context = ctx\r\n},\r\n复制代码追加数据getGoodsData () {\r\n\tconst _that = this\r\n\r\n\tService_getGoodsData.then((res) => {\r\n\t\tif (res.data) {\r\n\t\t\t_that.recycle_view_context.append(res.data.goods_list)\r\n\t\t}\r\n\t})\r\n},\r\n复制代码使用watch来实现dialog动效缘由之前写一个商城的时候，研究淘宝的商品属性选择弹窗的动效是一个什么过程，然后如何实现。过程如下：点击选择属性/购买/加入购物车按钮 => 蒙版层占满整个屏幕，然后渐渐显现出来，与此同时，下方的窗口从底部渐渐滑出。OK，其实这个过程很简单，点击按钮的时候，弹窗（占满整个屏幕）其实以及出现了，但是要等待蒙版层的背景颜色从transparent变为rgba(0, 0, 0, 0.6)，同时也在等待弹窗内容从transform:translate(-100%)变为transform:translate(0)。这个时候需要用到小程序官方开源的一个插件：\tminiprogram-computed实现Dialog.wxml<view\r\n      class=\"fixed_wrap\"\r\n      wx:if=\"{{is_show}}\"\r\n      catchtouchmove=\"onStopPageScroll\"\r\n>\r\n      <view class=\"dialog_wrap\">\r\n            <view\r\n                  class=\"mask\"\r\n                  style=\"background-color: {{bg_modal}}\"\r\n                  catchtap=\"onClose\"\r\n            ></view>\r\n            <view\r\n                  class=\"dialog_absolute_wrap\"\r\n                  style=\"transform:{{position_dialog}}\"\r\n            >\r\n                  <view\r\n                        class=\"dialog\"\r\n                        style=\"background-color: {{is_show_bg?'white':'transparent'}}\"\r\n                  >\r\n                        <image\r\n                              class=\"img_close\"\r\n                              src=\"../../assets/images/icon_close.svg\"\r\n                              mode=\"widthFix\"\r\n                              bindtap=\"onClose\"\r\n                              wx:if=\"{{is_show_close}}\"\r\n                        ></image>\r\n                        <slot></slot>\r\n                  </view>\r\n            </view>\r\n      </view>\r\n</view>\r\n复制代码dialog.jsimport computedBehavior from 'miniprogram-computed'\r\n\r\nComponent({\r\n\tbehaviors: [\r\n\t\tcomputedBehavior\r\n\t],\r\n\tproperties: {\r\n\t\tid: {\r\n\t\t\ttype: String\r\n\t\t},\r\n\t\tis_show_dialog: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tvalue: false\r\n\t\t},\r\n\t\tis_show_close: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tvalue: true\r\n\t\t},\r\n\t\tis_show_bg: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tvalue: true\r\n\t\t}\r\n\t},\r\n\tdata: {\r\n\t\tis_show: false,\r\n\t\tbg_modal: 'transparent',\r\n\t\tposition_dialog: 'translateY(120%)'\r\n\t},\r\n\twatch: {\r\n\t\tis_show_dialog: function (new_val){\r\n\t\t\tconst _that = this\r\n\r\n\t\t\tif (new_val) {\r\n\t\t\t\t_that.setData({\r\n\t\t\t\t\tis_show: true\r\n\t\t\t\t})\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t_that.setData({\r\n\t\t\t\t\t\tbg_modal: 'rgba(0, 0, 0, 0.6)',\r\n\t\t\t\t\t\tposition_dialog: 'translateY(0)'\r\n\t\t\t\t\t})\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_that.setData({\r\n\t\t\t\t\tbg_modal: 'transparent',\r\n\t\t\t\t\tposition_dialog: 'translateY(120%)'\r\n\t\t\t\t})\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t_that.setData({\r\n\t\t\t\t\t\tis_show: false\r\n\t\t\t\t\t})\r\n\t\t\t\t}, 300)\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\tonClose () {\r\n\t\t\tconst _that = this\r\n\r\n\t\t\t_that.setData({ is_show_dialog: false })\r\n\t\t},\r\n\t\tonTapDialog (e) {\r\n\t\t\tconst _that = this\r\n\r\n\t\t\t_that.triggerEvent('OnBottomDialog', { id: _that.data.id, event: e })\r\n\t\t},\r\n\t\tonStopPageScroll () {}\r\n\t}\r\n})\r\n复制代码dialog.less@import '../../theme/vars.less';\r\n\r\n.fixed_wrap {\r\n      position: fixed;\r\n      top: 0;\r\n      left: 0;\r\n      z-index: 10000;\r\n      width: 100vw;\r\n      height: 100vh;\r\n     \r\n}\r\n\r\n.dialog_wrap {\r\n      position: relative;\r\n      width: 100%;\r\n      height: 100%;\r\n\r\n      .mask {\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            transition: all ease 0.3s;\r\n      }\r\n\r\n      .dialog_absolute_wrap {\r\n            position: absolute;\r\n            bottom: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            transition: all ease 0.3s;\r\n\r\n            .dialog {\r\n                  position: relative;\r\n                  display: flex;\r\n                  flex-direction: column;\r\n                  width: 100%;\r\n                  box-sizing: border-box;\r\n                  background-color: white;\r\n                  border-top-left-radius: @radius_normal;\r\n                  border-top-right-radius: @radius_normal;\r\n\r\n                  .img_close {\r\n                        position: absolute;\r\n                        top: 10rpx;\r\n                        right: 10rpx;\r\n                        z-index: 1;\r\n                        width: 40rpx;\r\n                        height: 40rpx;\r\n                        padding: 20rpx;\r\n                        opacity: 0.3;\r\n                  }\r\n            }\r\n      }\r\n}\r\n复制代码自定义顶部NavBar缘由现在有很多商城app都会有在顶部NavBar上放各种“东西”比如搜索框的需求，但是NavBar上的胶囊又没办法自定义，这就导致NavBar上的搜索框或是其他元素会与胶囊错位，看起来效果很差，详情可看“网易严选小程序”，但是其实是有办法做到顶部NavBar完美布局的，这里就要用到一个获取胶囊定位以及尺寸的api\twx.getMenuButtonBoundingClientRect() ，通过这个api，然后使用\tres.statusBarHeight 这个变量，我们可以做很多事情。不过经过测试，目前已知在小米的一些型号的全面屏手机上，高度会有略微的偏移，需要做一定的适配。wx.getSystemInfo({\r\n\tsuccess(res){\r\n\t    console.log(res.statusBarHeight)\r\n\t},\r\n})\r\n复制代码实现具体实现我就不写了，等有时间抽空把组件重构一次后再分享给大家，下面写部分关键代码：//获取设备顶部 状态栏高度 和 顶部标题栏高度\r\nexport const GetDeviceBarHeight = () => {\r\n\tlet statusBarHeight\r\n\tlet titleBarHeight\r\n\r\n\twx.getSystemInfo({\r\n\t\tsuccess(res){\r\n\t\t\tlet totalTopHeight = 68\r\n\r\n\t\t\tif (res.model.indexOf('iPhone X') !== -1) {\r\n\t\t\t\ttotalTopHeight = 88\r\n\t\t\t}\r\n\t\t\telse if (res.model.indexOf('iPhone') !== -1) {\r\n\t\t\t\ttotalTopHeight = 64\r\n\t\t\t}\r\n\r\n\t\t\tstatusBarHeight = res.statusBarHeight\r\n\t\t\ttitleBarHeight = totalTopHeight - res.statusBarHeight\r\n\t\t},\r\n\t\tfailure () {\r\n\t\t\tstatusBarHeight = 0\r\n\t\t\ttitleBarHeight = 0\r\n\t\t}\r\n\t})\r\n\r\n\treturn {\r\n\t\tstatusBarHeight: statusBarHeight,\r\n\t\ttitleBarHeight: titleBarHeight\r\n\t}\r\n}\r\n\r\ndata: {\r\n        statusBarHeight: app.globalData.statusBarHeight + 'px',\r\n\t\ttitleBarHeight: app.globalData.titleBarHeight + 'px',\r\n\t\tnavigationBarHeight: app.globalData.statusBarHeight + 44 + 'px',\r\n\r\n\t\theight: 0,\r\n\t\ttop: 0\r\n},\r\n\r\n//动态设定 顶部操作按钮的高度和位置\r\nsetOptionsHeight () {\r\n\tconst _that = this\r\n\tconst { top, height } = wx.getMenuButtonBoundingClientRect()\r\n\r\n\t_that.setData({\r\n\t\theight: height - 1,\r\n\t\ttop: top + 2\r\n\t})\r\n}\r\n复制代码小程序分包加载但小程序的大小超过2M之后可以采用分包加载的方式加载页面，具体使用方式看官方文档\t小程序分包加载最后后续我会写一些单独的小程序组件并开源出来，不同于有赞的小程序库，他们提供的是一辆长得像淘宝的“改装车”，而我开源出来的是一些，跟谁都长的不像，想怎么改就怎么改的“改装车零件”。我在github开源了一个\t小程序开发手册 ，后续更多内容将在这个开源项目上更新，大家可以分享给开发小程序的同事，让他们少踩一点坑，大家少加一点班。周末愉快。", "pub_time": "2019-11-5 00:46", "author": "Rolan"}
{"title": "在腾讯Q3财报中站C位的品牌小程序，BAT态度大不同！ ", "content": "昨天，腾讯2019年Q3财报如“约”而至。其中，小程序数据格外亮眼，不仅日活跃用户超过3亿，商业化也表现强劲，中长尾小程序日均商业交易笔数同比增加超过一倍。值得注意的是，这组数据中，“品牌”二字尤其“夺目”，财报显示：品牌自营类小程序数量同比增长1倍以上；8%的品牌自营类小程序交易额同比增长100倍以上、56%的品牌自营类小程序交易额同比增长50%以上，在头部领跑下，中腰部正在崛起；超过1亿人次访问品牌自营类小程序。这一定程度上说明了越来越多的品牌选择了微信小程序作为重要阵地。因此，要让用户在众多品牌中一眼就能发现自己，品牌曝光是首要环节。对于企业而言，如果没做好品牌曝光，自家品牌就会淹没在“芸芸众生”之中，而这一局面，在搜索场景下尤为突出。比如，用户输入一个关键词，结果“数不胜数”，无论用户看多少眼，也不一定会注意到。于是，BAT三巨头接踵而至地基于自家搜索推出一个能力：品牌主页。直白点说，“品牌主页”就是：在搜索结果页中，将企业各类信息与服务放在一起整体展示，比如企业认证信息、小程序、服务等等，入口更直接。微信“品牌主页”叫作品牌官方区，于去年4月基于搜一搜推出，在公众号后台便可开通；相比之下，支付宝与百度则慢了好几拍，都是最近才推出小程序能力，前者叫品牌直达，后者称百度品牌名片。虽然叫法不同（以下统称时，称为“品牌主页”），但其目的是一致的，都是为了帮助企业更好地建立品牌效应、将服务充分触达用户，从而提升收益。但BAT三平台的属性不同，“品牌主页”的能力开放程度、玩法等也有所差异，并非都能满足所有企业的需求，企业们在选择上也就“不知所云”。对此，晓程序观察（yinghoo-tech）就来一次测评与PK，帮助企业们选择适合自己的“品牌主页”。1流量曝光：微信品牌官方区完胜？既然“品牌主页”是用来帮助企业更好地触达用户，对于企业与品牌而言，最关心的还是流量，比如：用户输入哪些关键词，才能直达“品牌主页”？如果品牌名称输入错误，“品牌主页”能不能显示？“品牌主页”在搜索结果中是怎么排序的？实际上，对于搜索平台来说，这些都是影响流量曝光不可忽略的因素。流量曝光第一环：入口微信：三种样式、三种入口，A级最突出在搜一搜的搜索结果页中，微信品牌官方区的有三种展示样式，如图，依次为A、B、C三种：A级与B级的品牌官方区可以添加公众号、小程序、服务和商品；C级样式仅允许将公众号展示。此外，A级与B级都有品牌详情页，C级样式并没有。在众多搜索结果中，A级样式会有一种“鹤立鸡群”的感觉，更容易建立品牌认知，尤其是小程序、公众号、服务、商品等都是卡片形式，入口更加“抢眼”。不过，A级样式并不是所有品牌都能开通的，三种样式各有不同的门槛。如图，要求中包括公众号与官方区点击量、是否有微信认证与商标认证、公众号注册时间等条件。值得注意的是，开通A级样式还有推广搜一搜的要求，即品牌主在投放广告时或在自有宣传渠道上，要有“微信搜一搜”搜索框露出。线上线下渠道都可以，比如：电梯间广告、户外大屏广告、易拉宝、门店宣传、自有小程序曝光、公众号文章广告、朋友圈广告等等。 支付宝&百度：品牌主页没有特殊展示，入口很“隐蔽”相较于微信官方区，支付宝品牌直达与百度品牌名片的样式则显得尤为“简陋”。展示上，支付宝品牌直达与其他搜索结果并无差别，而百度品牌名片本身即是一个小程序。所以，在入口上，支付宝品牌直达与百度品牌名片都不够突出。对于企业来说，“品牌主页”的作用，就是为了让用户在众多搜索结果中一眼就能看到自家品牌，而“与众不同”的样式，入口也就更“夺目”，这一点，微信官方区是合格的。从品牌曝光来看，支付宝与百度的“品牌主页”在入口上都没有明显优势。如此看来，微信品牌官方区完胜。流量曝光第二环：关键词配置对比完三家“品牌主页”的样式，再来看关键词配置。毕竟，用户输入什么关键词，才能将“品牌主页”搜索出来才是最重要的。微信：级别越高，可配置关键词数量越多刚刚提到，微信品牌官方区有A、B、C三种不同级别。所以，可配置的关键词数量也是不一样的，分别为5个、3个、1个。所以，这对企业来说，可操作空间不大，但仍旧需要将与品牌相关的常见关键词都加上。比如，开通A级官方区的“同程旅游网”，其相关的关键词有同程旅游、同程、同程艺龙等，但晓程序观察（yinghoo-tech）测试后发现，输入“同程艺龙”，并不会出现“同程旅游网”品牌官方区，说明其没有配置关键词“同程艺龙”。同样的问题，也出现在开通B级官方区的“麦当劳”上，搜索英文名称McDonald，就不会出现其品牌官方区。支付宝&百度：“关键词要与品牌名称完全一致”支付宝品牌直达与百度品牌名片的关键词完全不用主动配置，但是，对企业、对用户都极其不友好。因为，只有在用户精确搜索品牌词时，搜索结果中才会出现“品牌主页”。百度品牌名片更甚，据百度官方介绍，用户需要输入“品牌名+品牌名片”（如齐家网品牌名片），或者输入开发者在后台填写的企业全称。对此，晓程序观察也测试了一番，输入“齐家网”后，在搜索结果中，整个第一页都没有看到“齐家网品牌名片”的身影。因此，在“品牌主页”的关键词配置上，微信有一定的运营空间，而百度与支付宝则完全没有。流量曝光第三环：搜索排名对于搜索平台的逻辑来说，决定流量价值的，除了关键词，当然就是搜索结果页排名了。BAT三家“品牌主页”的排名规则，又有什么不一样？微信：“品牌主页”始终占据首位在搜一搜结果页中，微信官方区始终是以首位展示。比如，输入“同程”后，结果页中排在第一位的便是“同程旅游网”品牌官方区，而后才是文章、公众号、小程序、朋友圈等内容。当然前提是，需要针对特定搜索词才能保证官方区首位展示。不同级别的官方区，指定关键词数量也是不一样的。此外，搜索词申请也有一定的要求：须为品牌词汇：针对通用词汇，比如汉堡、保险等，不开放置顶申请；须具有品牌独占性：针对非品牌独占词汇，比如阿拉丁等，不开放置顶申请。支付宝：可通过运营手段来提升搜索排名相比于微信官方区首位展示，支付宝品牌直达的搜索排名则由算法决定。算法维度主要包括：搜索结果中品牌直达的访问和点击用户数、开通品牌直达后搜索带来的增量用户数等，而这些数据都可以利用运营手段来提升。需要注意的是，支付宝品牌直达内包括了小程序、生活号等内容；所以，企业们只需运营品牌直达即可，这样便能同时提升小程序与生活号的排名竞争力。比如，在运营活动中，就可以引导用户“上支付宝搜XXX”，从而改善搜索UV、搜索UV增量数据。百度：广告排在品牌主页前面作为一个搜索引擎平台，百度品牌名片的排名同样根据算法得到，至于逻辑目前还不太清楚。不过，据我们的测试来看，百度品牌名片并不会排在首位，“取而代之”的则是与关键词相关的广告内容。如图，输入“齐家网品牌名片”之后，出现在首位是与齐家网毫无关系的广告内容。综上，微信官方区首位展示，显然是最能帮助企业实现品牌曝光的。而支付宝与百度，还需要开发者在运营规范中自行摸索算法。比如，支付宝品牌直达的搜索UV就是其算法中一个很重要的因素。2在至关重要的拉新与转化上百度输了？对于企业而言，“品牌主页”能带来流量曝光是远远不够的，其更加看重的，仍是拉新与转化。这一点，目前只有微信品牌官方区与支付宝品牌直达能够做到。事实上，BAT三家“品牌主页”看似差别不大，都可以在“品牌主页”内添加小程序等入口，但在拉新与转化上，百度则略逊一筹。原因是微信与支付宝“品牌主页”具备以下两个能力：1.可在品牌主页内直接添加服务与商品在微信与支付宝的“品牌主页”内，开发者能够配置其小程序的服务或商品。品牌在搜索结果页中就能直接触达用户，转化能力更强。用户点击服务或商品后，落地页都是品牌关联的小程序，比如，在NIKE的微信品牌官方区内，点击商品，进入的就是“Nike耐克”小程序的商品详情页。目前，微信品牌官方区最多可在搜索结果页展示4个服务与3个商品；而支付宝品牌直达，仅可添加1-2个小程序服务。2.品牌主页可与功能直达打通在微信与支付宝“品牌主页”中，可与“功能直达”打通，也是其一项重要开放能力。（关于BAT三家功能直达，我们此前已有过测评对比，请点击阅读）在微信搜一搜中，品牌官方区的服务和商品也会出现在相关搜索结果中，拥有更多曝光；同样，用户在支付宝搜索的关键词与某功能关键词匹配时，便会触发功能直达，小程序内的服务便可直接出现在结果页中。相比之下，百度不仅在搜索结果页没有服务入口，在品牌详情页内也不可添加小程序内某个服务，目前只能起到展示作用。综上，无论是“品牌主页”样式，还是流量曝光，微信官方区都要更加完善；而支付宝与百度则处于刚刚起步的阶段，尤其是百度品牌名片，并没有将百度的搜索价值利用至最大化。那么，企业开发者们，BAT三家“品牌名片”，你们会怎么运营？欢迎留言哦~", "pub_time": "2019-11-22 00:12", "author": "Rolan"}
{"title": "【微信小程序】图片压缩-纯质量压缩，非长宽裁剪压缩 ", "content": "原理：利用canvas来实现，将图片绘制到canvas上，然后canvas转图片时，微信提供的一个方法wx.canvasToTempFilePath(Object object, Object this)，此方式可以指定生成图片的质量，下图是从官方API截的图：其中quality可以指定图片的质量，quality的值越小，图片越模糊，通过此方法可以实现图片的压缩注意：1.quality设置只对jpg格式的图片有效，使用时要将fileType设置为“jpg”， 此举可能会导致其它格式的图片变为jpg格式\r\n\r\n2.透明背景的png图片，绘制到canvas上使用此方式导出的图片是黑色背景，有需求的话是需要canvas先设置背景色的，请小伙伴们注意爬坑。有了这个参数，压缩就简单很多了，下面是代码：wxml<view>\r\n  <button bindtap=\"chooseImage\">选择图片</button>\r\n</view>\r\n\r\n<!-- 展示压缩后的图片 -->\r\n<view style=\"display: flex;justify-content: center;flex-direction: column\">\r\n  <image width=\"50\" mode=\"widthFix\" src=\"{{imagePath}}\"></image>\r\n</view>\r\n\r\n<button wx:if=\"{{imagePath.length>0}}\" bindtap=\"save\">点击下载压缩后的图片</button>\r\n\r\n<!-- 用来渲染的canvas --> \r\n<canvas canvas-id='attendCanvasId' class='myCanvas' style='width:{{cWidth}}px;height:{{cHeight}}px;position: fixed;top: -9999px;left: -9999px;'></canvas>jsPage({\r\n  data: {\r\n    imagePath: '',\r\n    quality: 0.2\r\n  },\r\n  onLoad: function (options) {\r\n  \r\n  },\r\n  /**\r\n  * 选项添加图片事件\r\n  */\r\n  chooseImage: function (e) {\r\n    var that = this;\r\n    wx.chooseImage({\r\n      sizeType: ['compressed'],  //可选择原图或压缩后的图片\r\n      sourceType: ['album', 'camera'], //可选择性开放访问相册、相机\r\n      success: result => {\r\n        wx.getImageInfo({\r\n          src: result.tempFilePaths[0],\r\n          success: function (res) {\r\n            that.setData({\r\n              cWidth: res.width,\r\n              cHeight: res.height\r\n            })\r\n            that.getCanvasImg(result.tempFilePaths, res.width, res.height, that.data.quality, function (res) {\r\n              that.setData({\r\n                imagePath: res.tempFilePath\r\n              });\r\n            });\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 质量压缩\r\n   */\r\n  getCanvasImg(tempFilePaths, canvasWidth, canvasHeight, quality, callback) {\r\n    var that = this; \r\n    const ctx = wx.createCanvasContext('attendCanvasId');\r\n    ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n    ctx.drawImage(tempFilePaths[0], 0, 0, canvasWidth, canvasHeight);\r\n    ctx.draw(false, function () {\r\n      wx.canvasToTempFilePath({\r\n        canvasId: 'attendCanvasId',\r\n        fileType: 'jpg',\r\n        quality: quality,\r\n        success: function success(res) {\r\n          callback && callback(res)\r\n        }, fail: function (e) {\r\n          wx.showToast({\r\n            title: '图片上传失败，请重新上传！',\r\n            icon: 'none'\r\n          })\r\n        }\r\n      });\r\n    });\r\n  },\r\n  /**\r\n   * 图片保存到相册\r\n   */\r\n  save(e) {\r\n    let that = this;\r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: that.data.imagePath,\r\n      success: function (res) {\r\n        console.log('图片已保存');\r\n      },\r\n      fail: function (res) {\r\n        console.log('保存失败');\r\n      }\r\n    })\r\n  },\r\n})注意点：注意设置canvas-id='attendCanvasId'canvas要离屏渲染，就是移出屏幕之外，但是元素还是显示的，position: fixed;top: -9999px;left: -9999px; 不能使用 display: none; 这样是获取不到canvas元素的。最后h5页面中也有提供这样的方法例如这样子：let canvas = document.createElement('canvas');\r\nlet ctx = canvas.getContext('2d');\r\nctx.drawImage(imagePath, 0, 0, w, h);\r\ncanvas.toDataURL('image/jpeg', quality);需要的小伙伴也可以自己研究研究哈...源码-欢迎star感谢ok, 结束，", "pub_time": "2019-11-13 00:17", "author": "Rolan"}
{"title": "从0到1开发一个小程序cli脚手架（三） --自定义命令 ", "content": "本文主要讲述关于如何实现自定义命令\r\ngithub地址：github.com/jinxuanzhen…\r\n觉得有用的朋友帮忙给项目一个star，谢谢\r\n\r\n系列内容，推荐从第一篇开始阅读：从0到1开发一个小程序cli脚手架（一）--创建页面/组件模版篇从0到1开发一个小程序cli脚手架（二） --版本发布/管理篇从0到1开发一个小程序cli脚手架（三） --自定义命令\r\n\r\n背景\r\n在写不同小程序的时候，突然发现每个小程序面临的场景和需求或多或少会有些差异化，比如说程序A会有生成doc的功能，程序B会有开启数据埋点的debug模式等等\r\n为了保证脚手架的通用性，我们并不能将这些差异化的功能一一实现，这时候就需要让用户实现自定义了\r\n\r\n准备工作\r\n最好看过之前的两篇文章并搭建过demo，里面有介绍一些项目的结构，实现思路，第三方包使用相关的东西\r\n\r\n开始\r\n\r\n梳理大概流程\r\n这里不多说了，老套路: config注册方法 -> 脚手架路由读取注册方法 -> 执行回调函数\r\n\r\n注册自定义命令\r\n既然是给开发者在实际项目中进行配置，那么自然在配置文件 xdk.config.js 文件中动手了，在配置文件中预留出一个口子，方便我们读取配置文件时获取json，因为开发者可能会注册多个自定义命令，我这里字段类型直接给的数组类型\r\n\r\n将字段customScripts配置好后，就开始配置自定义命令了，首先确定需要的属性\r\n\r\n[name], 命令名称肯定是要的\r\n[desc], 描述本质上可有可无，不影响功能，但是比较方便记忆\r\n[callback], 输入完命令之后要执行什么(回调函数主体)\r\n\r\n\r\n大概是这个样子，后续我会以生成sass文档为例来写一个自定义命令\r\n\r\n读取配置项\r\n回到xdk-cli这个项目，找到入口文件index.js，如果看过前面两篇文章，会知道首先要配置路由，这里调用第三方包commander来解析命令\r\n\r\n配置路由\r\n\r\n这里先看第一行，我用了前缀 run <cmd> 来解析，也就是说我们使用的时候必须输入xdk-cli run <cmd>，那么为什么不直接xdk-cli <cmd>呢？\r\n主要是为扩展考虑，避免命名重复导致功能被覆盖，而且自定义指令本质上只是xdk-cli脚手架诸多功能中的一项，放在第一层级实在有些不合时宜\r\n有些情况下，不太清楚当前项目下的自定义命令都有哪些，可以直接xdk-cli -h查看\r\n\r\n加装方法\r\n通过run 命令我们可以准确到达当前的action，接下来要做什么？\r\n自然是执行自定义命令的回调，在执行之前我们可以给他加装一系列方法，更利于去二次开发，我这里采用的是改变this指向的方法，将当前函数作用于绑定到originPrototype上\r\n\r\n\r\n方法库列表\r\n我这里道导出了封装好log的开启子进程方法，log方法，还有交互命令行方法，当然也可以导出更多，主要看自己的需求\r\n\r\n到这里为止，这样一套流程就跑通了，下面我写一个小例子\r\n\r\n案例：生成sass文档\r\n可以看到我调用的子进程，和日志都是通过接口公开出来已经在脚手架进行过统一处理的方法，并没有去多做事情\r\n当然你也可以使用交互命令，让自定义命令更加友好，例如：\r\n\r\n配合package.json\r\n可以在package.json的scripts里注册命令，简化我们的调用\r\n直接可以简写为npm start\r\n\r\n最后\r\n这篇比较简单，基本上只是针对回调方法做了包装与回传，目标是为了方便让开发者去定制一些功能\r\n到此为止，三篇文章下来整个小程序开发脚手架的大概逻辑和框架已经非常清晰明了，后续的话有可能会针对npm支持, 和npm包的开发模板进行更新，觉得有帮助的同学可以关注下~~", "pub_time": "2019-11-29 00:52", "author": "Rolan"}
{"title": "解决小程序渲染复杂长列表，内存不足问题 ", "content": "问题回顾：我们有一个列表展示页，是无限瀑布流式的，展示的元素我们封装成了单个组件，暂且叫它Item组件。这个瀑布流包含若干个Item组件，并且这个Item组件也比较复杂，包含各种展示样式（根据不同类型，大概有9种吧，反正渲染节点很多），在进行滑动的过程中，item大概加载30-40个以后，就会造成小程序内存不足而退出，蓝瘦香菇......【干货在最后，小程序代码片段奉上】\r\n\r\n解决思路：\r\n将超出屏幕一定部分的列表内的组件进行不渲染的处理（也就是用wx:if卸载掉组件），当到达渲染临界点时再开始渲染；保证每次少量的数据展示。\r\n\r\n我们的项目中是保持15条Item，我们是每次分页请求5条，按照前5条，中间5条和后5条来划分，如果不在这个范围，则用一个等高度的骨架代替，并且卸载这些组件\r\n\r\n初期实现方式（后面有更优化的方式）\r\n使用曝光监听，当一个Item曝光时，记录Item高度，并放到数组里面，作为骨架的填充高度，如果已经记录了高度，则不再重复记录；曝光时向外传递一个当前渲染范围的中心值（比如当前Item所属页码，或者当前Item索引），以此进行处理；\r\n\r\n这里有一点要注意，如果你的列表item组件比较复杂，需要在ready的时候将记录的高度设置为item最小高度，不然组件重新装载时会有一定的渲染时间，在临界点会造成跳屏【此处已经通过骨架组件解决，可以忽略，只是作为踩坑记录】\r\n\r\n此时优化点\r\n\r\n为避免频繁setData和渲染，做了防抖函数，时间是600ms\r\n\r\n此时缺点\r\n\r\n滑动特别快时，会出现白屏，是因为曝光监听是在组件里面，而超快速滚动时，组件没有装载进来，也无法进行曝光监听，所以无法触发，这里考虑用骨架组件进行二次监听曝光\r\n\r\n优化迭代\r\n\r\n将骨架组件作为外壳套在Item外面（用slot），并对骨架进行监听曝光，可以解决上面缺点\r\n给骨架组件做一个常规骨架屏样式，而不是纯白色，看起来更优雅\r\n\r\n继续发现问题\r\n经过一系列的实践，上面的方案有些问题，其中最麻烦的就是，需要对外传递一个当前index，然后控制前后数据展示；这里对于每个用到skeleton组件的页面来说，都要重复的写一个方法来承接这个index，然后渲染页面对应的数据。\r\n优化\r\n依然是监听skeleton曝光，这里监听的方案变为出现在屏幕上下n屏的内容块进行展示，此范围外的内容块就卸载掉。\r\n如图所示\r\n\r\n核心代码\r\n     // 修改了监听是否显示内容的方法，改为前后showNum屏高度渲染\r\n     // 监听进入屏幕的范围relativeToViewport({top: xxx, bottom: xxx})\r\n      let info = SystemInfo.getInfo() //获取系统信息\r\n      let { windowHeight = 667 } = info.source.system\r\n      let showNum = 2 //超过屏幕的数量，目前这个设置是上下2屏\r\n      let listItemContainer = this.createIntersectionObserver()\r\n      listItemContainer.relativeToViewport({ top: showNum * windowHeight, bottom: showNum * windowHeight })\r\n        .observe(`#list-item-${this.data.skeletonId}`, (res) => {\r\n        \t// 此处来控制slot展示，详见代码片段\r\n        })\r\n       \r\n复制代码干货\r\n话不多说，干货放后面，点击获取代码片段\r\n最后，还是尽量减少节点数，优化代码", "pub_time": "2019-12-9 00:12", "author": "Rolan"}
