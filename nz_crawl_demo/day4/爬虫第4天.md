# 爬虫第4天  

* 多线程爬虫  
* 动态网页爬虫 
* 绕过图形验证码
* 字体反爬  



## 多线程 爬虫  

### 深度优先 

```python
#encoding:utf-8
import re
import requests
#深度爬取 递归
from lxml import etree

headers = {
    "User-Agent":"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"
}


def getHTML(url):
    try:
        res = requests.get(url,headers=headers)
        # print(res.content.decode('utf-8'))
        return res.content.decode('utf-8')
    except:
        return ""

def get_son_url(url):

    text = getHTML(url) #获取页面内容
    html = etree.HTML(text)
    #规则
    aList = html.xpath("//a/@href")
    return aList
def main(url):
    if deep_dict[url] > 4:
        return
    print("\t" * deep_dict[url],"当前层级:%d" % deep_dict[url])
    #获取网页子url
    sonurl_list = get_son_url(url)
    for sonurl in sonurl_list:
        #过滤有效链接
        if sonurl.startswith('http') or sonurl.startswith('https'):
            if sonurl not in deep_dict:#过滤重复的url
                deep_dict[sonurl] = deep_dict[url] + 1
                main(sonurl) #递归爬取子url
if __name__ == "__main__":
    url = "https://www.so.com/s?q=%E5%B2%9B%E5%9B%BD%E7%A7%8D%E5%AD%90"
    deep_dict = {}
    deep_dict[url] = 1 #默认层级为1
    main(url)


```

### 广度优先 

```
#encoding:utf-8
import re
import requests
#深度爬取 递归
from lxml import etree

headers = {
    "User-Agent":"Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"
}


def getHTML(url):
    try:
        res = requests.get(url,headers=headers)
        # print(res.content.decode('utf-8'))
        return res.content.decode('utf-8')
    except:
        return ""

def get_son_url(url):

    text = getHTML(url) #获取页面内容
    html = etree.HTML(text)
    #规则
    aList = html.xpath("//a/@href")
    return aList
def main(startUrl):
    #用列表 模拟队列
    url_queue = []
    url_queue.append(startUrl)
    while len(url_queue) > 0:
        url = url_queue.pop(0)  # 每次取出列表第一个
        print("\t" * deep_dict[url], "当前层级:%d" % deep_dict[url])
        if deep_dict[url] < 4:
            sonList = get_son_url(url)  # 获取子url列表
            for son_url in sonList:
                # 过滤有效的url
                if son_url.startswith('http') or son_url.startswith('https'):
                    if son_url not in deep_dict:  # 过滤重复url
                        deep_dict[son_url] = deep_dict[url] + 1  # 层级加1
                        url_queue.append(son_url)  # 将子url进入队列
if __name__ == "__main__":
    url = "https://www.so.com/s?q=%E5%B2%9B%E5%9B%BD%E7%A7%8D%E5%AD%90"
    deep_dict = {}
    deep_dict[url] = 1 #默认层级为1
    main(url)


```



### 函数 线程方式

```python
import time
import threading
def driving():
    for x in range(3):
        print('%s正在开车' % threading.current_thread()) #当前线程
        time.sleep(2)


def loling():
    for x in range(3):
        print('%s正在撸' % threading.current_thread()) #当前线程
        time.sleep(2)


def main():
    t1 = threading.Thread(target=driving) #实例化线程 并且制定要做什么
    t2 = threading.Thread(target=loling)

    t1.start()
    t2.start()
    print(threading.enumerate()) #查看进程的数量
if __name__ == "__main__":
    main()
```



### 类多线程

```python
import time
import threading
class DrivingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print('%s正在开车' % threading.current_thread())  # 当前线程
            time.sleep(2)

class LolingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print('%s正在撸' % threading.current_thread()) #当前线程
            time.sleep(2)


def main():
    t1 = DrivingThread() #实例化线程 并且制定要做什么
    t2 = LolingThread()

    t1.start()
    t2.start()
    print(threading.enumerate()) #查看线程的数量
if __name__ == "__main__":
    main()
```



### 锁机制

```python
import threading

VALUE = 0
gLock = threading.Lock()

def add_value():
    global VALUE
    gLock.acquire()
    for x in range(10000000):
        VALUE +=1
    gLock.release()
    print("value:%d" % VALUE)

def main():
    for x in range(2):
        t = threading.Thread(target=add_value)
        t.start()

if __name__ == "__main__":
     main()

```



### 生产者和消费者  锁

```python
import threading
import random
import time
gMoney = 10000
gLock = threading.Lock()

gTotalTimes = 10
gTime = 0

# 生产者
class Producer(threading.Thread):
    def run(self):
        global gMoney
        global gTime
        while True:
            money= random.randint(1000,10000)
            gLock.acquire() #上锁
            if gTime >= gTotalTimes:
                gLock.release()
                break
            gMoney += money
            print("%s挣了%d元钱,余额%d元钱" % (threading.current_thread(),money,gMoney))
            gTime +=1
            gLock.release() #释放锁
            time.sleep(0.5)
#消费者
class Consumer(threading.Thread):
    def run(self):
        global gMoney
        while True:
            money = random.randint(1000,10000)
            gLock.acquire()
            if gMoney >= money:
                gMoney -= money
                print("%s消费了%d元钱,余额%d元钱" % (threading.current_thread(), money, gMoney))
            else:
                if gTime >= gTotalTimes:
                    gLock.release()
                    break
                print("%s消费了%d元钱,余额%d元钱,余额不足" % (threading.current_thread(), money, gMoney))
            gLock.release()
            time.sleep(0.5)

def main():

    for x in range(3):
        t = Consumer(name="消费者线程%d" % x)
        t.start()

    for x in range(3):
        t = Producer(name="生产者线程%d" % x)
        t.start()

if __name__ == "__main__":
    main()
```

